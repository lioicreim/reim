/**
 * 필터 코드 생성기
 * 프리셋 설정과 티어 리스트 데이터를 기반으로 .filter 파일 형식의 코드를 생성합니다.
 */

import { staticIdentifiedRules } from "./static-identified-rules";
import bases from "@/data/bases.json";
import classes from "@/data/classes.json";
import currencyTiers from "@/data/currency-tiers.json";
import filterRules from "@/data/filter-rules.json";
import presets from "@/data/presets.json";
import currencyItemCategories from "@/data/currency-item-categories.json";
import modsTiersData from "@/data/mods-tiers.json";
import uniquesTiers from "@/data/uniques-tiers.json";

/**
 * 필터 코드 생성
 * @param {Object} options - 필터 생성 옵션
 * @param {string} options.presetId - 프리셋 ID
 * @param {boolean} options.isPS5 - PS5 모드 여부
 * @param {Object} options.excludedOptions - 제외 옵션
 * @param {Object} options.customGearTiers - 커스텀 장비 티어 (로컬스토리지에서)
 * @param {Object} options.customCurrencyTiers - 커스텀 화폐 티어 (로컬스토리지에서)
 * @param {string} options.selectedLeague - 선택된 리그 (기본값, early, normal, late, ssf)
 * @returns {string} 생성된 필터 코드
 */
export function generateFilterCode(options) {
  const {
    presetId = "starter",
    soundOption = "default", // default(PC), ps5, s_only, none
    excludedOptions = {},
    customGearTiers = {},
    customCurrencyTiers = {},
    customModsTiers = {},
    excludedItems = {}, // 추가: 제외된 아이템 목록 { category: [itemNames] }
    selectedLeague = "default",
    soundSettings = [], // 사용자가 설정한 사운드 매핑 (localStorage에서 전달, 배열 형태)
    lang = "ko", // 주석 언어 설정 (ko: 한국어, en: 영어)
    quickFilterSettings = {}, // 빠른 설정 추가
    uniqueTierStyles = {} // 유니크 티어 스타일 추가
  } = options;

  const isPS5 = soundOption === "ps5";
  const isSOnly = soundOption === "s_only";
  const isSilent = soundOption === "none";

  const preset = presets.presets.find((p) => p.id === presetId);
  if (!preset) {
    throw new Error(`Preset not found: ${presetId}`);
  }

  const lines = [];

  // 필터 헤더
  lines.push("# Filter generated by GAMEBOX");
  lines.push(`# Preset: ${preset.nameKo || preset.name}`);
  lines.push(`# Generated: ${new Date().toISOString()}`);
  lines.push("");

  // 리그 키 결정 (기본값은 normal 사용)
  const leagueKey = selectedLeague === "default" ? "normal" : selectedLeague;

  // 글로별 사운드 활성화 여부 매핑 생성
  const disabledFiles = new Set();
  const disabledIngameIds = new Set();
  
  (soundSettings || []).forEach(s => {
    if (s.enabled === false) {
      if (s.pcFile) {
        disabledFiles.add(s.pcFile);
        if (!s.pcFile.startsWith("custom_sound/")) {
          disabledFiles.add(`custom_sound/${s.pcFile}`);
        }
      }
      // ingameId와 ps5Slot 모두 체크
      if (s.ingameId) disabledIngameIds.add(Number(s.ingameId));
      if (s.ps5Slot) disabledIngameIds.add(Number(s.ps5Slot));
    }
  });

  // 사운드 활성화 체크 헬퍼
  const isSndEnabled = (styles) => {
    if (isSilent) return false;
    if (!styles) return false;

    // CustomAlertSound 체크
    if (styles.customSound) {
      if (disabledFiles.has(styles.customSound)) return false;
      const cleanFile = styles.customSound.replace("custom_sound/", "");
      if (disabledFiles.has(cleanFile)) return false;
    }

    // PlayAlertSound 체크 (id 기반)
    if (styles.playAlertSound?.id && disabledIngameIds.has(Number(styles.playAlertSound.id))) {
      return false;
    }
    
    // ingameSound (Unique 스타일) 체크
    if (styles.ingameSound?.id && disabledIngameIds.has(Number(styles.ingameSound.id))) {
      return false;
    }
    
    // ps5Sound (StyleSettingsModal 스타일) 체크
    if (styles.ps5Sound && disabledIngameIds.has(Number(styles.ps5Sound))) {
      return false;
    }

    return true;
  };

  // 베이직 사운드 옵션 전달
  const soundContext = { soundOption, isPS5, isSOnly, isSilent, soundSettings, isSndEnabled };

  // 섹션: 레벨링 (최우선 - 화폐 및 베이스 아이템보다 먼저 처리)
  if (options.quickFilterSettings?.leveling) {
    lines.push("");
    lines.push("#######################################################");
    lines.push("# 레벨링 | Leveling");
    lines.push("#######################################################");
    lines.push("");
    generateLevelingRules(
      lines,
      options.quickFilterSettings.leveling,
      options.quickFilterSettings.levelingClassSelection,
      soundContext,
      lang
    );
  }

  // 섹션: 찬스 아이템 (베이스 아이템보다 우선 처리)
  if (options.quickFilterSettings?.chance?.enabled) {
    lines.push("");
    lines.push("#######################################################");
    lines.push("# 찬스 아이템 | Chance Items");
    lines.push("#######################################################");
    lines.push("");
  }
  generateChanceRules(
    lines,
    preset,
    options.quickFilterSettings?.chance,
    soundContext,
    lang
  );

  // 섹션: 베이스 아이템 (장비 베이스)
  lines.push("");
  lines.push("#######################################################");
  lines.push("# 베이스 아이템 | Base Items");
  lines.push("#######################################################");
  lines.push("");
  generateGearRules(lines, preset, customGearTiers, excludedOptions, soundContext, excludedItems["gear-bases"] || [], lang);

  // 섹션: 미감정 아이템
  if (preset.rules.showUnidentified) {
    lines.push("");
    lines.push("#######################################################");
    lines.push("# 미감정 아이템 | Unidentified Items");
    lines.push("#######################################################");
    lines.push("");
    generateUnidentifiedRules(lines, preset, customGearTiers, soundContext, lang);
  }

  // 섹션: 기타 (서판 등 - 화폐보다 우선 처리)
  if (options.quickFilterSettings?.others) {
    lines.push("");
    lines.push("#######################################################");
    lines.push("# 기타 | Others");
    lines.push("#######################################################");
    lines.push("");
    generateOthersRules(
      lines,
      options.quickFilterSettings.others,
      soundContext,
      lang
    );
  }

  // 로직 추가: 유니크 섹션
  if (options.quickFilterSettings?.uniques) {
    if (options.quickFilterSettings.uniques.enabled) {
      lines.push("");
      lines.push("#######################################################");
      lines.push("# 유니크 아이템 | Unique Items");
      lines.push("#######################################################");
      lines.push("");
      generateUniquesRules(
        lines,
        preset,
        options.quickFilterSettings.uniques, // Pass the uniques settings directly
        soundContext,
        excludedItems["uniques"] || [], // Assuming excludedItems might have a 'uniques' category
        uniqueTierStyles, // Pass uniqueTierStyles here
        lang
      );
    }
  }

  // 섹션: 화폐
  lines.push("");
  lines.push("#######################################################");
  lines.push("# 화폐 | Currency");
  lines.push("#######################################################");
  lines.push("");
  generateCurrencyRules(lines, preset, customCurrencyTiers, leagueKey, soundContext, excludedItems["currency"] || [], lang, options.quickFilterSettings);

  // 섹션: 골드
  if (options.quickFilterSettings?.gold) {
    lines.push("");
    lines.push("#######################################################");
    lines.push("# 골드 | Gold");
    lines.push("#######################################################");
    lines.push("");
    generateGoldRules(lines, options.quickFilterSettings.gold, lang);
  }




  // 섹션: 미가공 젬
  if (options.quickFilterSettings?.uncutGems) {
    lines.push("");
    lines.push("#######################################################");
    lines.push("# 미가공 젬 | Uncut Gems");
    lines.push("#######################################################");
    lines.push("");
    generateUncutGemsRules(
      lines,
      options.quickFilterSettings.uncutGems,
      soundContext,
      lang
    );
  }

  // 섹션: 경로석
  if (options.quickFilterSettings?.waystones) {
    lines.push("");
    lines.push("#######################################################");
    lines.push("# 경로석 | Waystones");
    lines.push("#######################################################");
    lines.push("");
    generateWaystonesRules(
      lines,
      options.quickFilterSettings.waystones,
      soundContext,
      lang
    );
  }

  // 섹션: 탐험
  if (options.quickFilterSettings?.expedition) {
    lines.push("");
    lines.push("#######################################################");
    lines.push("# 탐험 | Expedition");
    lines.push("#######################################################");
    lines.push("");
    generateExpeditionRules(
      lines,
      options.quickFilterSettings.expedition,
      soundContext,
      lang
    );
  }

  // 베이스 아이템 규칙 생성 (빠른 설정에서)
  if (options.quickFilterSettings?.baseItems) {
    lines.push("");
    lines.push("#######################################################");
    lines.push("# 베이스 아이템 | Base Items");
    lines.push("#######################################################");
    lines.push("");
    generateBaseItemsRules(
      lines,
      options.quickFilterSettings.baseItems,
      soundContext,
      lang
    );
  }

  // 베이스 아이템 (소켓 & 퀄리티) 규칙 생성
  if (options.quickFilterSettings?.baseItemsSocketQuality) {
    lines.push("");
    lines.push("#######################################################");
    lines.push("# 베이스 아이템 (소켓 & 퀄리티) | Base Items (Socket & Quality)");
    lines.push("#######################################################");
    lines.push("");
    generateBaseItemsSocketQualityRules(
      lines,
      options.quickFilterSettings.baseItemsSocketQuality,
      soundContext,
      lang
    );
  }

  // 감정된 무기 규칙 생성
  if (options.quickFilterSettings?.identifiedWeapons) {
    lines.push("");
    lines.push("#######################################################");
    lines.push("# 감정된 아이템 - 공격 무기 | Identified - Attack Weapons");
    lines.push("#######################################################");
    lines.push("");
    generateIdentifiedWeaponsRules(
      lines,
      options.quickFilterSettings.identifiedWeapons,
      soundContext,
      lang
    );
  }

  // 감정된 시전 무기 규칙 생성
  if (options.quickFilterSettings?.identifiedCastingWeapons) {
    lines.push("");
    lines.push("#######################################################");
    lines.push("# 감정된 아이템 - 시전 무기 | Identified - Casting Weapons");
    lines.push("#######################################################");
    lines.push("");
    generateIdentifiedCastingWeaponsRules(
      lines,
      options.quickFilterSettings.identifiedCastingWeapons,
      soundContext,
      lang
    );
  }

  // 감정된 생명력 방어구 규칙 생성
  if (options.quickFilterSettings?.identifiedLifeArmour) {
    lines.push("");
    lines.push("#######################################################");
    lines.push("# 감정된 아이템 - 생명력 방어구 | Identified - Life Armour");
    lines.push("#######################################################");
    lines.push("");
    generateIdentifiedLifeArmourRules(
      lines,
      options.quickFilterSettings.identifiedLifeArmour,
      soundContext,
      lang
    );
  }

  // 감정된 에너지 보호막 방어구 규칙 생성
  if (options.quickFilterSettings?.identifiedESArmour) {
    lines.push("");
    lines.push("#######################################################");
    lines.push("# 감정된 아이템 - 에너지 보호막 방어구 | Identified - Energy Shield Armour");
    lines.push("#######################################################");
    lines.push("");
    generateIdentifiedESArmourRules(
      lines,
      options.quickFilterSettings.identifiedESArmour,
      soundContext,
      lang
    );
  }

  // 감정된 에너지 보호막 방어구 규칙 생성
  if (options.quickFilterSettings?.identifiedESArmour) {
    lines.push("");
    lines.push("#######################################################");
    lines.push("# 감정된 아이템 - 에너지 보호막 방어구 | Identified - Energy Shield Armour");
    lines.push("#######################################################");
    lines.push("");
    generateIdentifiedESArmourRules(
      lines,
      options.quickFilterSettings.identifiedESArmour,
      soundContext,
      lang
    );
  }

  // 감정된 장신구 규칙 생성
  if (options.quickFilterSettings?.identifiedJewellery) {
    lines.push("");
    lines.push("#######################################################");
    lines.push("# 감정된 아이템 - 장신구 | Identified - Jewellery");
    lines.push("#######################################################");
    lines.push("");
    generateIdentifiedJewelleryRules(
      lines,
      options.quickFilterSettings.identifiedJewellery,
      soundContext,
      lang
    );
  }

  // 섹션: 호신부
  if (options.quickFilterSettings?.charms) {
    lines.push("");
    lines.push("#######################################################");
    lines.push("# 호신부 | Charms");
    lines.push("#######################################################");
    lines.push("");
    generateCharmsRules(
      lines,
      options.quickFilterSettings.charms,
      soundContext,
      lang
    );
  }

  return lines.join("\n");
}

/**
 * 레벨링 규칙 생성
 */
function generateLevelingRules(lines, levelingSettings, levelingClassSelection, soundContext, lang = "ko") {
  const { isSndEnabled } = soundContext;
  if (!levelingSettings || !levelingSettings.enabled) {
    return;
  }

  const rules = levelingSettings.rules || [];

  rules.forEach((rule) => {
    if (!rule.enabled) return;

    // 무기/방어구 규칙 특수 처리
    if (rule.id === "leveling_weapons_armor") {
      if (levelingClassSelection) {
        generateLevelingClassSelectionRules(lines, levelingClassSelection, lang);
      }
      return;
    }

    // 규칙 이름 주석
    const ruleName = lang === "ko" ? rule.nameKo || rule.name : rule.name;
    lines.push(`# ${ruleName}`);

    // RID 주석
    lines.push(`# [RID: ${rule.id}]`);

    // Show/Hide
    lines.push(rule.type === "hide" ? "Hide" : "Show");

    // Class 조건
    if (rule.conditions?.class) {
      const classValue = rule.conditions.class.value;
      if (Array.isArray(classValue)) {
        const classes = classValue.map((c) => `"${c}"`).join(" ");
        lines.push(`  Class == ${classes}`);
      } else {
        lines.push(`  Class == "${classValue}"`);
      }
    }

    // BaseType 조건 (복수 - baseTypes 배열)
    if (rule.conditions?.baseTypes && Array.isArray(rule.conditions.baseTypes)) {
      const baseTypes = rule.conditions.baseTypes.map((b) => `"${b}"`).join(" ");
      lines.push(`  BaseType == ${baseTypes}`);
    }

    // AreaLevel 조건
    if (rule.conditions?.areaLevel) {
      const { operator, value } = rule.conditions.areaLevel;
      lines.push(`  AreaLevel ${operator} ${value}`);
    }

    // Quality 조건
    if (rule.conditions?.quality) {
      const { operator, value } = rule.conditions.quality;
      lines.push(`  Quality ${operator} ${value}`);
    }

    // Sockets 조건
    if (rule.conditions?.sockets) {
      const { operator, value } = rule.conditions.sockets;
      lines.push(`  Sockets ${operator} ${value}`);
    }

    // 스타일 적용
    if (rule.styles) {
      const styles = rule.styles;

      if (styles.fontSize) {
        lines.push(`  SetFontSize ${styles.fontSize}`);
      }

      if (styles.textColor) {
        const { r, g, b, a } = styles.textColor;
        lines.push(`  SetTextColor ${r} ${g} ${b} ${a}`);
      }

      if (styles.borderColor) {
        const { r, g, b, a } = styles.borderColor;
        lines.push(`  SetBorderColor ${r} ${g} ${b} ${a}`);
      }

      if (styles.backgroundColor) {
        const { r, g, b, a } = styles.backgroundColor;
        lines.push(`  SetBackgroundColor ${r} ${g} ${b} ${a}`);
      }

      if (styles.playEffect) {
        lines.push(`  PlayEffect ${styles.playEffect}`);
      }

      if (styles.minimapIcon) {
        const { size, color, shape } = styles.minimapIcon;
        lines.push(`  MinimapIcon ${size} ${color} ${shape}`);
      }

      if (styles.customSound && isSndEnabled(styles)) {
        lines.push(`  CustomAlertSound "${styles.customSound}" 300`);
      }
    }

    lines.push("");
  });
}

/**
 * 장비 규칙 생성
 */
function generateGearRules(
  lines,
  preset,
  customGearTiers,
  excludedOptions,
  soundContext,
  excludedItemsList = [],
  lang = "ko"
) {
  const { isSilent } = soundContext;
  const gearTiers = preset.rules.gearTiers || [];
  const minIlvl = preset.itemLevel.min;
  const useBaseMinIlvl = preset.itemLevel.useBaseMinIlvl;

  // 티어별로 그룹화
  const itemsByTier = {};
  gearTiers.forEach((tier) => {
    itemsByTier[tier] = [];
  });

  // 베이스 아이템을 티어별로 분류
  Object.keys(bases).forEach((itemName) => {
    const item = bases[itemName];
    let finalTier = item.tier || 4;

    // 커스텀 티어 확인
    if (customGearTiers[itemName]) {
      const customTier = customGearTiers[itemName];
      // S->1, A->2, B->3, C->4, D->5, E->6 변환
      const tierMap = { S: 1, A: 2, B: 3, C: 4, D: 5, E: 6 };
      finalTier = tierMap[customTier] || finalTier;
    }

    // 프리셋에서 지정한 티어에 포함되는지 확인
    if (gearTiers.includes(finalTier)) {
      if (!itemsByTier[finalTier]) {
        itemsByTier[finalTier] = [];
      }
      itemsByTier[finalTier].push({ name: itemName, ...item });
    }
  });

  // 티어별로 규칙 생성
  gearTiers.forEach((tier) => {
    // 커스텀 티어 반영 및 제외 항목 필터링
    const currentTierItems = (itemsByTier[tier] || [])
      .filter(item => !excludedItemsList.includes(item.name));
    if (currentTierItems.length === 0) return;

    // 클래스별로 그룹화
    const itemsByClass = {};
    currentTierItems.forEach((item) => {
      if (!itemsByClass[item.class]) {
        itemsByClass[item.class] = [];
      }
      itemsByClass[item.class].push(item);
    });

    // 클래스별로 규칙 생성
    Object.keys(itemsByClass).forEach((className) => {
      // 데이터(bases.json, classes.json)에는 "Armours"로 되어 있으나
      // 실제 필터에서는 "Body Armours"로 출력해야 함
      const displayClassName = className === "Armours" ? "Body Armours" : className;

      const classItems = itemsByClass[className];
      const baseTypes = classItems.map((item) => item.name);
      const capIlvl = classes[className]?.capIlvl;
      const classMinIlvl = classes[className]?.minIlvl;
      const presetId = preset.id;

      // T15+6모드의 경우 최소 레벨과 최대 레벨 두 규칙을 모두 생성
      if (
        tier === 1 &&
        presetId === "verystrict" &&
        capIlvl &&
        classMinIlvl !== null &&
        classMinIlvl !== undefined
      ) {
        // 최소 레벨 규칙 생성
        generateTier1Rule(
          lines,
          tier,
          displayClassName,
          baseTypes,
          classMinIlvl,
          capIlvl,
          preset,
          classItems,
          minIlvl,
          useBaseMinIlvl,
          soundContext,
          "min"
        );
        // 최대 레벨 규칙 생성
        generateTier1Rule(
          lines,
          tier,
          displayClassName,
          baseTypes,
          classMinIlvl,
          capIlvl,
          preset,
          classItems,
          minIlvl,
          useBaseMinIlvl,
          soundContext,
          "max"
        );
      } else {
        // 일반 규칙 생성
        generateTier1Rule(
          lines,
          tier,
          displayClassName,
          baseTypes,
          classMinIlvl,
          capIlvl,
          preset,
          classItems,
          minIlvl,
          useBaseMinIlvl,
          soundContext,
          null
        );
      }
    });
  });
}

/**
 * 1티어 규칙 생성 헬퍼 함수
 */
function generateTier1Rule(
  lines,
  tier,
  className,
  baseTypes,
  classMinIlvl,
  capIlvl,
  preset,
  classItems,
  minIlvl,
  useBaseMinIlvl,
  soundContext,
  levelType
) {
  const { isPS5, isSOnly, isSilent, soundSettings, isSndEnabled } = soundContext;
  // SECTION 주석
  lines.push(`# [SECTION: gear_bases]`);

  // RID 주석 (간단한 형식)
  const levelSuffix = levelType ? `_${levelType}` : "";
  lines.push(
    `# [RID: gear_bases_t${tier}_${className.toLowerCase()}${levelSuffix}]`
  );
  lines.push("Show");

  // ItemLevel 조건
  // 1티어의 경우 프리셋에 따라 최소/최대 레벨 조건이 다름
  if (tier === 1) {
    const presetId = preset.id;

    if (presetId === "starter" || presetId === "strict") {
      // 리그 스타터, T1-T14: 최소 레벨부터 최대 레벨까지 표시
      if (classMinIlvl !== null && classMinIlvl !== undefined) {
        lines.push(`  ItemLevel >= ${classMinIlvl}`);
      } else {
        lines.push(`  ItemLevel >= ${minIlvl}`);
      }
      // 최대 레벨 제한은 없음 (최소 레벨 이상이면 모두 표시)
    } else if (presetId === "verystrict") {
      // T15+6모드: 최소 레벨 또는 최대 레벨
      if (levelType === "min") {
        // 최소 레벨 규칙
        if (classMinIlvl !== null && classMinIlvl !== undefined) {
          lines.push(`  ItemLevel >= ${classMinIlvl}`);
        } else {
          lines.push(`  ItemLevel >= ${minIlvl}`);
        }
      } else if (levelType === "max") {
        // 최대 레벨 규칙
        if (capIlvl) {
          lines.push(`  ItemLevel >= ${capIlvl}`);
        }
      }
    } else if (presetId === "uber" || presetId === "vaal") {
      // Uber, Vaal: 최대 레벨만 표시
      if (capIlvl) {
        lines.push(`  ItemLevel >= ${capIlvl}`);
      } else if (classMinIlvl !== null && classMinIlvl !== undefined) {
        lines.push(`  ItemLevel >= ${classMinIlvl}`);
      } else {
        lines.push(`  ItemLevel >= ${minIlvl}`);
      }
    } else {
      // 기본값: 최대 레벨 사용
      if (capIlvl) {
        lines.push(`  ItemLevel >= ${capIlvl}`);
      } else if (classMinIlvl !== null && classMinIlvl !== undefined) {
        lines.push(`  ItemLevel >= ${classMinIlvl}`);
      } else {
        lines.push(`  ItemLevel >= ${minIlvl}`);
      }
    }
  } else {
    // 클래스별 최소 레벨 우선 사용
    if (classMinIlvl !== null && classMinIlvl !== undefined) {
      // 클래스에 최소 레벨이 있으면 사용
      lines.push(`  ItemLevel >= ${classMinIlvl}`);
    } else if (useBaseMinIlvl) {
      // 베이스별 최소 레벨 사용
      // 각 아이템마다 개별 규칙을 만들거나, 최소값을 사용
      const minBaseIlvl = Math.min(
        ...classItems.map((item) => {
          // bases.json에서 minIlvl이 있는지 확인
          return item.minIlvl || minIlvl;
        })
      );
      lines.push(`  ItemLevel >= ${minBaseIlvl}`);
    } else {
      // 프리셋의 전역 최소 레벨 사용
      lines.push(`  ItemLevel >= ${minIlvl}`);
    }
  }

  // Class 조건
  lines.push(`  Class == "${className}"`);

  // BaseType 조건
  if (baseTypes.length > 0) {
    const baseTypeLine = baseTypes.map((name) => `"${name}"`).join(" ");
    lines.push(`  BaseType == ${baseTypeLine}`);
  }

  // Rarity 조건
  if (tier === 3 && preset.rules.gearTier3Rarity) {
    lines.push(`  Rarity == ${preset.rules.gearTier3Rarity}`);
  } else if (!preset.rules.showNormalItems && !preset.rules.showMagicItems) {
    lines.push(`  Rarity == Rare`);
  }

  // TODO: 특출 아이템 처리
  // 특출: 1소켓이 2소켓으로, 2소켓이 3소켓으로 드롭되는 아이템
  // 특출 아이템 리스트를 받으면 여기에 조건 추가 예정
  // 예: Sockets >= 2 (1소켓 아이템이 2소켓 이상으로 드롭된 경우)

  // 스타일 적용
  const tierColors = getTierColors(tier);
  lines.push(`  SetFontSize ${tierColors.fontSize}`);
  lines.push(`  SetTextColor ${tierColors.textColor}`);
  lines.push(`  SetBorderColor ${tierColors.borderColor}`);
  lines.push(`  SetBackgroundColor ${tierColors.backgroundColor}`);

  // PlayEffect
  if (tierColors.playEffect) {
    lines.push(`  PlayEffect ${tierColors.playEffect}`);
  }

  // 사운드 (PS5 모드면 인게임 사운드로 변환, 아니면 커스텀 사운드)
  if (isSilent) {
    // 무음
  } else if (isSOnly) {
    if (tier === 1) {
      const setting = soundSettings.find(s => s.id === `gear_t${tier}`);
      if (setting?.enabled !== false && isSndEnabled({ customSound: setting?.pcFile || `5_item_t1.mp3`, playAlertSound: { id: setting?.ingameId || setting?.ps5Slot || 5 } })) {
          // PS5 모드이거나, 설정이 'default'(기본/인게임)인 경우 -> PlayAlertSound
          const useIngame = isPS5 || (setting?.type === "default");
          
          if (useIngame) {
              // ingameId 우선, 없으면 ps5Slot (기존 호환)
              const slot = setting?.ingameId || setting?.ps5Slot || 5; 
              const vol = setting?.volume || 300;
              lines.push(`  PlayAlertSound ${slot} ${vol}`);
          } else {
              // Custom Sound
              const rawFile = setting?.pcFile || `5_item_t1.mp3`;
              const file = rawFile.startsWith("custom_sound/") ? rawFile : `custom_sound/${rawFile}`;
              const vol = setting?.volume || 300;
              lines.push(`  CustomAlertSound "${file}" ${vol}`);
          }
      }
    }
  } else {
    // 일반 모드
    const setting = soundSettings.find(s => s.id === `gear_t${tier}`);
    if (setting?.enabled !== false && isSndEnabled({ customSound: setting?.pcFile || tierColors.customSound, playAlertSound: { id: setting?.ingameId || setting?.ps5Slot || (isPS5 ? 5 : null) } })) {
        const useIngame = isPS5 || (setting?.type === "default");

        if (useIngame) {
             const slot = setting?.ingameId || setting?.ps5Slot || (isPS5 ? 5 : null);
             if (slot) {
                lines.push(`  PlayAlertSound ${slot} ${setting?.volume || 300}`);
             }
        } else {
             // Custom
             const rawFile = setting?.pcFile || tierColors.customSound;
             const vol = setting?.volume || 300;
             if (rawFile) {
               const file = rawFile.startsWith("custom_sound/") ? rawFile : `custom_sound/${rawFile}`;
               lines.push(`  CustomAlertSound "${file}" ${vol}`);
             }
        }
    }
  }

  lines.push("");
}

/**
 * 미감정 아이템 규칙 생성 (빛기둥)
 */
function generateUnidentifiedRules(lines, preset, customGearTiers, soundContext, lang = "ko") {
  const unidentifiedTiers = preset.rules.unidentifiedTiers || [];
  if (unidentifiedTiers.length === 0) return;

  const gearTiers = preset.rules.gearTiers || [];

  // 미감정 아이템은 1티어만 적용 (스크린샷 기준)
  if (!gearTiers.includes(1)) return;

  // 5등급: Red 빛기둥
  if (unidentifiedTiers.includes(5)) {
    generateUnidentifiedTierRule(
      lines,
      5,
      "Red",
      gearTiers,
      customGearTiers,
      soundContext
    );
  }

  // 4등급: Yellow 빛기둥
  if (unidentifiedTiers.includes(4)) {
    generateUnidentifiedTierRule(
      lines,
      4,
      "Yellow",
      gearTiers,
      customGearTiers,
      soundContext
    );
  }

  // 3등급 이하는 unidentifiedTiers에 포함되지 않으면 숨김 (별도 처리 불필요)
}

/**
 * 미감정 등급별 규칙 생성
 */
function generateUnidentifiedTierRule(
  lines,
  grade,
  effectColor,
  gearTiers,
  customGearTiers,
  soundContext
) {
  const { isSilent, isSOnly, isPS5 } = soundContext;
  // 1티어 아이템만 처리
  if (!gearTiers.includes(1)) return;

  // 1티어 아이템들을 클래스별로 그룹화
  const itemsByClass = {};

  Object.keys(bases).forEach((itemName) => {
    const item = bases[itemName];
    let finalTier = item.tier || 4;

    // 커스텀 티어 확인
    if (customGearTiers[itemName]) {
      const customTier = customGearTiers[itemName];
      const tierMap = { S: 1, A: 2, B: 3, C: 4, D: 5, E: 6 };
      finalTier = tierMap[customTier] || finalTier;
    }

    // 1티어만 처리
    if (finalTier === 1) {
      const className = item.class;
      if (!itemsByClass[className]) {
        itemsByClass[className] = [];
      }
      itemsByClass[className].push({ name: itemName, ...item });
    }
  });

  // 클래스별로 규칙 생성
  Object.keys(itemsByClass).forEach((className) => {
    // 데이터에는 "Armours"로 되어 있으나 실제 필터에서는 "Body Armours"로 출력해야 함
    const displayClassName = className === "Armours" ? "Body Armours" : className;
    const ridClassName = displayClassName.toLowerCase().replace(" ", "_");

    const classItems = itemsByClass[className];
    const baseTypes = classItems.map((item) => item.name);
    const capIlvl = classes[className]?.capIlvl;

    // SECTION 주석
    lines.push(`# [SECTION: unidentified_items]`);

    // RID 주석
    lines.push(
      `# [RID: unidentified_grade${grade}_t1_${ridClassName}]`
    );
    lines.push("Show");

    // 미감정 등급 조건
    lines.push(`  UnidentifiedItemTier == ${grade}`);

    // 1티어는 최대 레벨(capIlvl) 이상만 표시
    if (capIlvl) {
      lines.push(`  ItemLevel >= ${capIlvl}`);
    }

    // Class 조건
    lines.push(`  Class == "${displayClassName}"`);

    // BaseType 조건
    if (baseTypes.length > 0) {
      const baseTypeLine = baseTypes.map((name) => `"${name}"`).join(" ");
      lines.push(`  BaseType == ${baseTypeLine}`);
    }

    // 빛기둥 효과 (PlayEffect)
    lines.push(`  PlayEffect ${effectColor}`);

    // 스타일은 기본값 사용 (또는 프리셋별로 다를 수 있음)
    // 여기서는 빛기둥만 강조하므로 기본 스타일 사용
    lines.push(`  SetFontSize 45`);
    lines.push(`  SetTextColor 255 255 255 255`);
    lines.push(`  SetBorderColor 255 255 255 255`);
    lines.push(`  SetBackgroundColor 0 0 0 255`);

    // TODO: 특출 아이템 처리
    // 특출: 1소켓이 2소켓으로, 2소켓이 3소켓으로 드롭되는 아이템
    // 특출 아이템 리스트를 받으면 여기에 조건 추가 예정
    // 예: Sockets >= 2 (1소켓 아이템이 2소켓 이상으로 드롭된 경우)

    lines.push("");
  });
}

function generateCurrencyRules(
  lines,
  preset,
  customCurrencyTiers,
  leagueKey,
  soundContext,
  excludedItemsList = [],
  lang = "ko",
  quickFilterSettings = {}
) {
  const { isPS5, isSOnly, isSilent, soundSettings, isSndEnabled } = soundContext;
  const tierMapping = { S: "S", A: "A", B: "B", C: "C", D: "D", E: "E" };
  const tierOrder = { S: 1, A: 2, B: 3, C: 4, D: 5, E: 6 };

  // 1. 리그별 화폐 데이터 준비
  const leagueCurrencyData = currencyTiers[leagueKey] || currencyTiers.normal || {};
  const itemToTier = {};
  Object.keys(leagueCurrencyData).forEach((tier) => {
    if (leagueCurrencyData[tier]) {
      leagueCurrencyData[tier].forEach((item) => {
        itemToTier[item] = tier;
      });
    }
  });

  // 2. 화폐 표시 등급 설정 (minTier)
  const currencySettings = quickFilterSettings?.currency || {};
  const minTier = currencySettings?.minTier || "E";
  const minTierVal = tierOrder[minTier] || 6;

  // 3. 커스텀 화폐 규칙 우선 처리 (StackSize 등)
  if (currencySettings.enabled && currencySettings.rules) {
    currencySettings.rules.forEach((rule) => {
      if (!rule.enabled) return;

      const ruleName = lang === "ko" ? rule.nameKo || rule.name : rule.name;
      lines.push(`# ${ruleName}`);
      lines.push(`# [RID: ${rule.id}]`);
      lines.push("Show");

      if (rule.conditions) {
        if (rule.conditions.stackSize) {
           const { operator, value } = rule.conditions.stackSize;
           lines.push(`  StackSize ${operator} ${value}`);
        }
        if (rule.conditions.class) {
           const { operator, value } = rule.conditions.class;
           const valStr = Array.isArray(value) ? value.map(v => `"${v}"`).join(" ") : `"${value}"`;
           lines.push(`  Class ${operator} ${valStr}`);
        }
        if (rule.conditions.baseType) {
           const { operator, value } = rule.conditions.baseType;
           const valStr = Array.isArray(value) ? value.map(v => `"${v}"`).join(" ") : `"${value}"`;
           lines.push(`  BaseType ${operator} ${valStr}`);
        }
        if (rule.conditions.baseTypes) {
           const values = rule.conditions.baseTypes;
           if (Array.isArray(values) && values.length > 0) {
             lines.push(`  BaseType ${values.map(v => `"${v}"`).join(" ")}`);
           }
        }
        if (rule.conditions.areaLevel) {
           const { operator, value } = rule.conditions.areaLevel;
           lines.push(`  AreaLevel ${operator} ${value}`);
        }
      }

      if (rule.styles) {
        const styles = rule.styles;
        if (styles.fontSize) lines.push(`  SetFontSize ${styles.fontSize}`);
        if (styles.textColor) lines.push(`  SetTextColor ${styles.textColor.r} ${styles.textColor.g} ${styles.textColor.b} ${styles.textColor.a}`);
        if (styles.borderColor) lines.push(`  SetBorderColor ${styles.borderColor.r} ${styles.borderColor.g} ${styles.borderColor.b} ${styles.borderColor.a}`);
        if (styles.backgroundColor) lines.push(`  SetBackgroundColor ${styles.backgroundColor.r} ${styles.backgroundColor.g} ${styles.backgroundColor.b} ${styles.backgroundColor.a}`);
        if (styles.playEffect) lines.push(`  PlayEffect ${styles.playEffect}`);
        if (styles.minimapIcon) lines.push(`  MinimapIcon ${styles.minimapIcon.size} ${styles.minimapIcon.color || "White"} ${styles.minimapIcon.shape || "Circle"}`);
        if (styles.customSound && isSndEnabled(styles)) lines.push(`  CustomAlertSound "${styles.customSound}" ${styles.soundVolume || 300}`);
      }
      lines.push("");
    });
  }

  // 4. 섹션별 화폐 출력 (카테고리별로 모아서)
  const categoryOrder = [
    "currency",      // 일반 화폐
    "runes",         // 룬
    "essences",      // 에센스
    "uncut_gems",    // 미가공 젬 (내부 처리)
    "lineage_gems",  // 혈통 젬
    "soul_cores",    // 영혼핵
    "idosl",         // 우상
    "delirium",      // 환영
    "breach",        // 균열
    "abyssal",       // 심연
    "expedition",    // 탐험
    "ancient_bones", // 고대 유골
    "tablet",        // 판석
    "ritual_omen",   // 의식 징조
    "jewels",        // 주얼
    "charm",         // 부적
    "flask",         // 플라스크
    "waystones",     // 경로석 (내부 처리)
    "pinnacle_key",  // 정점 열쇠
    "map_fragments", // 지도 조각
    "vault_key",     // 금고실 열쇠
    "incubators"     // 인큐베이터
  ];
  
  // 이미 별도 함수에서 처리하는 카테고리는 제외
  const excludedCategories = ["uncut_gems", "waystones", "gold"];
  
  const allCategories = Array.from(new Set([...categoryOrder, ...Object.keys(currencyItemCategories)]))
    .filter(cat => !excludedCategories.includes(cat));
  const processedItems = new Set();

  allCategories.forEach((category) => {
    // 해당 섹션 활성화 여부 체크 (기본 화폐 섹션은 currencySettings.enabled로 판단)
    const sectionEnabled = (category === "currency") 
      ? currencySettings.enabled 
      : (quickFilterSettings[category]?.enabled !== false);
    
    if (!sectionEnabled) return;

    const categoryItems = currencyItemCategories[category] || [];
    if (categoryItems.length === 0) return;

    // 티어별 아이템 분류
    const itemsByTier = { S: [], A: [], B: [], C: [], D: [], E: [] };
    let categoryHasDisplayableItems = false;

    categoryItems.forEach((itemName) => {
      if (excludedItemsList.includes(itemName)) return;
      if (processedItems.has(itemName)) return;

      // 커스텀 티어 또는 기본 티어 결정
      let tier = customCurrencyTiers[itemName]?.[leagueKey] || itemToTier[itemName];
      if (!tier) return;

      // 최소 티어 필터링
      const mappedTierKey = tierMapping[tier] || tier;
      if ((tierOrder[mappedTierKey] || 99) > minTierVal) return;

      itemsByTier[tier].push(itemName);
      processedItems.add(itemName);
      categoryHasDisplayableItems = true;
    });

    if (!categoryHasDisplayableItems) return;

    // 섹션 시작 헤더 (카테고리당 단 한 번만 출력)
    lines.push(`#######################################################`);
    lines.push(`# [SECTION: ${category}]`);
    lines.push(`#######################################################`);

    // 티어 정렬 고정 (S -> E 순서로 반드시 출력)
    ["S", "A", "B", "C", "D", "E"].forEach((tier) => {
      const items = itemsByTier[tier];
      if (!items || items.length === 0) return;

      const tierKey = tierMapping[tier] || tier;
      const tierColors = getCurrencyTierColors(tierKey);

      const rid = (category === "currency") ? `currency_${tier.toLowerCase()}` : `currency_${category}_${tier.toLowerCase()}`;
      lines.push(`# [RID: ${rid}]`);
      lines.push("Show");

      // 클래스 조건 처리
      let itemClass = "Stackable Currency";
      if (category === "lineage_gems") itemClass = "Support Gems";
      else if (category === "ritual_omen") itemClass = "Omen";
      else if (category === "jewels") itemClass = "Jewels";
      else if (category === "charm") itemClass = "Charms";
      else if (category === "soul_cores" || category === "idosl") itemClass = "Augment";
      else if (category === "flask") itemClass = "Flasks";
      
      lines.push(`  Class "${itemClass}"`);
      lines.push(`  BaseType == ${items.map(n => `"${n}"`).join(" ")}`);
      
      // 스타일 적용
      lines.push(`  SetFontSize ${tierColors.fontSize}`);
      lines.push(`  SetTextColor ${tierColors.textColor}`);
      lines.push(`  SetBorderColor ${tierColors.borderColor}`);
      lines.push(`  SetBackgroundColor ${tierColors.backgroundColor}`);
      if (tierColors.playEffect) lines.push(`  PlayEffect ${tierColors.playEffect}`);
      if (tierColors.minimapIcon) lines.push(`  MinimapIcon ${tierColors.minimapIcon}`);

      // 사운드 적용
      const setting = soundSettings.find(s => s.id === `currency_${tierKey.toLowerCase()}`);
      if (!isSilent) {
        if (isPS5 || setting?.type === "default") {
          const slot = setting?.ingameId || setting?.ps5Slot || (isPS5 ? ({S:5,A:1,B:2,C:2}[tierKey] || 2) : null);
          if (slot) lines.push(`  PlayAlertSound ${slot} ${setting?.volume || 300}`);
        } else {
          if (!isSOnly || tierKey === "S") {
            const soundFile = setting?.pcFile || tierColors.customSound;
            if (soundFile && (setting?.enabled !== false) && isSndEnabled({ customSound: soundFile })) {
              const finalFile = soundFile.startsWith("custom_sound/") ? soundFile : `custom_sound/${soundFile}`;
              lines.push(`  CustomAlertSound "${finalFile}" ${setting?.volume || 300}`);
            }
          }
        }
      }
      lines.push("");
    });
    lines.push("");
  });

  // 5. 미분류 아이템 (Etc)
  const etcItemsByTier = { S: [], A: [], B: [], C: [], D: [], E: [] };
  let hasEtc = false;
  Object.keys(itemToTier).forEach(itemName => {
    if (processedItems.has(itemName) || excludedItemsList.includes(itemName)) return;
    const tier = itemToTier[itemName];
    const tVal = tierOrder[tierMapping[tier] || tier] || 99;
    if (tVal <= minTierVal) {
      etcItemsByTier[tier].push(itemName);
      hasEtc = true;
    }
  });

  if (hasEtc) {
    Object.keys(etcItemsByTier).forEach(tier => {
      const items = etcItemsByTier[tier];
      if (items.length === 0) return;
      lines.push(`# [SECTION: currency_etc]`);
      lines.push(`# [RID: currency_etc_${tier.toLowerCase()}]`);
      lines.push("Show");
      lines.push(`  Class "Stackable Currency"`);
      lines.push(`  BaseType == ${items.map(n => `"${n}"`).join(" ")}`);
      
      const tierColors = getCurrencyTierColors(tierMapping[tier] || tier);
      lines.push(`  SetFontSize ${tierColors.fontSize}`);
      lines.push(`  SetTextColor ${tierColors.textColor}`);
      lines.push(`  SetBorderColor ${tierColors.borderColor}`);
      lines.push(`  SetBackgroundColor ${tierColors.backgroundColor}`);
      if (tierColors.playEffect) lines.push(`  PlayEffect ${tierColors.playEffect}`);
      if (tierColors.minimapIcon) lines.push(`  MinimapIcon ${tierColors.minimapIcon}`);
      lines.push("");
    });
  }
}

/**
 * 장비 티어별 색상 및 스타일
 */
function getTierColors(tier) {
  const tierStyles = {
    1: {
      fontSize: 45,
      textColor: "0 0 0 255",
      borderColor: "0 0 0 255",
      backgroundColor: "255 255 255 255",
      playEffect: "Red",
      customSound: "custom_sound/1_gear_t1.mp3",
    },
    2: {
      fontSize: 45,
      textColor: "255 255 255 255",
      borderColor: "255 255 255 255",
      backgroundColor: "204 90 138 255",
      playEffect: "Orange",
      customSound: "custom_sound/2_gear_t2.mp3",
    },
    3: {
      fontSize: 45,
      textColor: "255 255 255 255",
      borderColor: "255 255 255 255",
      backgroundColor: "205 82 80 255",
      playEffect: "Yellow",
      customSound: "custom_sound/3_gear_t3.mp3",
    },
    4: {
      fontSize: 42,
      textColor: "0 0 0 255",
      borderColor: "0 0 0 255",
      backgroundColor: "255 165 0 255",
      playEffect: null,
      customSound: "custom_sound/4_gear_t4.mp3",
    },
  };

  return tierStyles[tier] || tierStyles[4];
}

/**
 * 화폐 티어별 색상 및 스타일
 */
function getCurrencyTierColors(tier) {
  const tierStyles = {
    S: {
      fontSize: 45,
      textColor: "255 0 0 255",
      borderColor: "255 0 0 255",
      backgroundColor: "255 255 255 255",
      playEffect: "Red",
      minimapIcon: "0 Red Star",
      customSound: "custom_sound/1_currency_s.mp3",
    },
    A: {
      fontSize: 45,
      textColor: "255 255 255 255",
      borderColor: "255 255 255 255",
      backgroundColor: "240 35 120 255",
      playEffect: "Orange",
      minimapIcon: "0 Orange Circle",
      customSound: "custom_sound/2_currency_a.mp3",
    },
    B: {
      fontSize: 45,
      textColor: "255 255 255 255",
      borderColor: "255 255 255 255",
      backgroundColor: "240 90 35 255",
      playEffect: "Yellow",
      minimapIcon: "1 Yellow Circle",
      customSound: "custom_sound/3_currency_b.mp3",
    },
    C: {
      fontSize: 42,
      textColor: "0 0 0 255",
      borderColor: "0 0 0 255",
      backgroundColor: "249 150 25 255",
      playEffect: null,
      minimapIcon: "1 Yellow Circle",
      customSound: "custom_sound/4_currency_c.mp3",
    },
    D: {
      fontSize: 42,
      textColor: "0 0 0 255",
      borderColor: "0 0 0 255",
      backgroundColor: "210 178 135 255",
      playEffect: null,
      minimapIcon: null,
      customSound: null,
    },
    E: {
      fontSize: 38,
      textColor: "220 175 132 255",
      borderColor: "0 0 0 255",
      backgroundColor: "0 0 0 255",
      playEffect: null,
      minimapIcon: null,
      customSound: null,
    },
  };

  return tierStyles[tier] || tierStyles.D;
}

/**
 * 골드 규칙 생성
 */
function generateGoldRules(lines, goldSettings, lang = "ko") {
  // 골드가 비활성화되어 있으면 모든 규칙을 Hide로 생성
  // enabled가 undefined일 경우 기본값 true로 처리
  const shouldHideAll = goldSettings.enabled === false;

  goldSettings.rules.forEach((rule) => {
    // 골드가 비활성화되어 있거나 개별 규칙이 비활성화되어 있으면 Hide로 변경
    const shouldHide = shouldHideAll || !rule.enabled;

    if (shouldHide) {
      // 비활성화된 경우 코드 자체를 생성하지 않음 (사용자 요청 사항)
      // Hide 규칙을 생성하고 싶으면 모달에서 "Hide" 타입을 선택해야 함
      return;
    }

    // 제목을 주석으로 추가 (언어 설정에 따라)
    const title = lang === "ko" 
      ? (rule.nameKo || rule.name) 
      : (rule.nameEn || rule.name);
    if (title) {
      lines.push(`# ${title}`);
    }

    // RID 주석
    lines.push(`# [RID: ${rule.id}]`);

    // Show/Hide
    lines.push(rule.type === "hide" ? "Hide" : "Show");

    // Class 조건 (골드는 일반적으로 "Stackable Currency" 또는 "Currency")
    // 기본값 규칙은 "Currency", 나머지는 "Stackable Currency"
    if (rule.id === "gold_default") {
      lines.push(`  Class == "Currency"`);
    } else {
      lines.push(`  Class == "Stackable Currency"`);
    }

    // BaseType 조건
    lines.push(`  BaseType == "골드"`);

    // AreaLevel 조건
    if (rule.conditions?.areaLevel) {
      const { operator, value } = rule.conditions.areaLevel;
      lines.push(`  AreaLevel ${operator} ${value}`);
    }

    // StackSize 조건
    if (rule.conditions?.stackSize) {
      const { operator, value } = rule.conditions.stackSize;
      lines.push(`  StackSize ${operator} ${value}`);
    }

    // 스타일 적용 (Show 타입만, Hide로 변경된 경우 스타일 적용 안함)
    if (!shouldHide && rule.type === "show" && rule.styles) {
      if (rule.styles.fontSize) {
        lines.push(`  SetFontSize ${rule.styles.fontSize}`);
      }

      if (rule.styles.textColor) {
        const { r, g, b, a } = rule.styles.textColor;
        lines.push(`  SetTextColor ${r} ${g} ${b} ${a}`);
      }

      if (rule.styles.borderColor) {
        const { r, g, b, a } = rule.styles.borderColor;
        lines.push(`  SetBorderColor ${r} ${g} ${b} ${a}`);
      }

      if (rule.styles.backgroundColor) {
        const { r, g, b, a } = rule.styles.backgroundColor;
        lines.push(`  SetBackgroundColor ${r} ${g} ${b} ${a}`);
      }

      if (rule.styles.playEffect) {
        lines.push(`  PlayEffect ${rule.styles.playEffect}`);
      }
    }

    lines.push("");
  });
}

/**
 * 찬스 아이템 규칙 생성
 */
function generateChanceRules(lines, preset, chanceSettings, soundContext, lang = "ko") {
  const { isPS5, isSOnly, isSilent, isSndEnabled } = soundContext;
  // 빠른 설정에서 체크해제했으면 Hide, 기본값은 Show
  const isEnabled = chanceSettings?.enabled !== false; // 기본값 true
  const showHide = isEnabled ? "Show" : "Hide";

  // SECTION 주석
  lines.push("#==================================================");
  lines.push("# [SECTION: chance]");
  lines.push("# 찬스 아이템 | Chance Base");
  lines.push("#==================================================");
  lines.push("");

  // RID 주석
  lines.push("# 찬스 아이템");
  lines.push("# [RID: chance_base]");
  lines.push(showHide);

  // 조건
  lines.push(`  BaseType == "Timeless Jewel" "Silver Charm" "Heavy Belt"`);
  lines.push(`  Rarity == Normal`);
  lines.push(`  Corrupted False`);

  // 스타일
  lines.push(`  SetFontSize 45`);
  lines.push(`  SetTextColor 255 0 0 255 #빨강`);
  lines.push(`  SetBorderColor 255 0 0 255 #빨강`);
  lines.push(`  SetBackgroundColor 31 12 8 255 #붉은색계열 블랙`);
  lines.push(`  MinimapIcon 2 Brown Kite`);

  // 사운드 처리
  const presetId = preset.id;
  // Vaal 프리셋에서는 A티어 이하 사운드 제거이므로 사운드 코드 제거
  if (presetId !== "vaal") {
    const chanceSndStyle = { customSound: "2_currency_a.mp3", playAlertSound: { id: 1 } };
    if (!isSilent && !isSOnly && isSndEnabled(chanceSndStyle)) {
        if (isPS5) {
            lines.push(`  PlayAlertSound 1 300`);
        } else {
            lines.push(`  CustomAlertSound "custom_sound/2_currency_a.mp3" 300`);
        }
    }
  }
  // Vaal 프리셋에서는 사운드 코드를 추가하지 않음

  lines.push("");
}

/**
 * 레벨링 직업 선택 규칙 생성
 */
function generateLevelingClassSelectionRules(lines, levelingClassSelection, lang = "ko") {
  // 활성화되지 않았으면 규칙 생성 안함
  if (!levelingClassSelection.enabled) {
    return;
  }

  // SECTION 주석 (언어별)
  lines.push("#==================================================");
  lines.push("# [SECTION: leveling_class_selection]");
  lines.push(lang === "ko" ? "# 레벨링 직업 선택" : "# Leveling Class Selection");
  lines.push("#==================================================");
  lines.push("");

  const hasWeaponSelection = levelingClassSelection.weaponTypes.length > 0;
  const hasArmourSelection = levelingClassSelection.armourTypes.length > 0;

  // 무기 규칙 생성
  if (hasWeaponSelection) {
    generateLevelingWeaponRule(
      lines,
      levelingClassSelection,
      "gear-leveling-weapons"
    );
  }

  // 방어구 규칙 생성
  if (hasArmourSelection) {
    generateLevelingArmourRule(
      lines,
      levelingClassSelection,
      "gear-leveling-armour"
    );
  }

  // 선택이 없으면 모든 무기/방어구 적용 (장신구 제외)
  if (!hasWeaponSelection && !hasArmourSelection) {
    generateLevelingAllGearRule(
      lines,
      levelingClassSelection,
      "gear-leveling-all"
    );
  }
}

/**
 * 레벨링 무기 규칙 생성
 */
function generateLevelingWeaponRule(
  lines,
  levelingClassSelection,
  ruleIdPrefix
) {
  const weaponTypeMap = {
    spears: "Spears",
    talismans: "Talismans",
    quarterstaves: "Quarterstaves",
    sceptres: "Sceptres",
    wands: "Wands",
    staves: "Staves",
    bows: "Bows",
    quivers: "Quivers",
    crossbows: "Crossbows",
    one_hand_maces: "One Hand Maces",
    two_hand_maces: "Two Hand Maces",
    foci: "Foci",
  };

  const classNames = levelingClassSelection.weaponTypes
    .map((type) => weaponTypeMap[type])
    .filter(Boolean)
    .map((name) => `"${name}"`)
    .join(" ");

  if (!classNames) return;

  // Rarity별로 규칙 생성
  const rarityTypes = [];
  if (levelingClassSelection.rarity.rare) {
    rarityTypes.push({ type: "Rare", id: "rare" });
  }
  if (levelingClassSelection.rarity.magic) {
    rarityTypes.push({ type: "Magic", id: "magic" });
  }
  if (levelingClassSelection.rarity.normal) {
    rarityTypes.push({ type: "Normal", id: "normal" });
  }

  if (rarityTypes.length === 0) return;

  rarityTypes.forEach((rarity) => {
    // 제목 주석
    lines.push(
      `# ${rarity.type} Leveling Weapons (${ruleIdPrefix}-${rarity.id})`
    );

    // RID 주석
    lines.push(`# [RID: ${ruleIdPrefix}-${rarity.id}]`);

    // Show
    lines.push("Show");

    // AreaLevel 조건
    lines.push("  AreaLevel <= 65");

    // Class 조건 (무기 클래스들)
    lines.push(`  Class == ${classNames}`);

    // Rarity 조건
    lines.push(`  Rarity == ${rarity.type}`);

    // 스타일 (예시: White 효과)
    lines.push("  PlayEffect White");
    lines.push("  MinimapIcon 2 White Kite");

    lines.push("");
  });
}

/**
 * 레벨링 방어구 규칙 생성
 */
function generateLevelingArmourRule(
  lines,
  levelingClassSelection,
  ruleIdPrefix
) {
  // 방어구 타입별 BaseArmour, BaseEvasion, BaseEnergyShield 조건
  const armourTypeConditions = {
    AR: {
      baseArmour: ">= 1",
      baseEvasion: "== 0",
      baseEnergyShield: "== 0",
    },
    ES: {
      baseArmour: "== 0",
      baseEvasion: "== 0",
      baseEnergyShield: ">= 1",
    },
    EV: {
      baseArmour: "== 0",
      baseEvasion: ">= 1",
      baseEnergyShield: "== 0",
    },
    "AR/ES": {
      baseArmour: ">= 1",
      baseEvasion: "== 0",
      baseEnergyShield: ">= 1",
    },
    "AR/EV": {
      baseArmour: ">= 1",
      baseEvasion: ">= 1",
      baseEnergyShield: "== 0",
    },
    "EV/ES": {
      baseArmour: "== 0",
      baseEvasion: ">= 1",
      baseEnergyShield: ">= 1",
    },
    "AR/EV/ES": {
      baseArmour: ">= 1",
      baseEvasion: ">= 1",
      baseEnergyShield: ">= 1",
    },
  };

  // 방어구 Class 목록
  const armourClasses = [
    "Body Armours",
    "Boots",
    "Gloves",
    "Helmets",
    "Shields",
  ]
    .map((name) => `"${name}"`)
    .join(" ");

  // Rarity별로 규칙 생성
  const rarityTypes = [];
  if (levelingClassSelection.rarity.rare) {
    rarityTypes.push({ type: "Rare", id: "rare" });
  }
  if (levelingClassSelection.rarity.magic) {
    rarityTypes.push({ type: "Magic", id: "magic" });
  }
  if (levelingClassSelection.rarity.normal) {
    rarityTypes.push({ type: "Normal", id: "normal" });
  }

  if (rarityTypes.length === 0) return;

  // 방어구 타입별로 규칙 생성
  levelingClassSelection.armourTypes.forEach((armourType) => {
    const conditions = armourTypeConditions[armourType];
    if (!conditions) return;

    rarityTypes.forEach((rarity) => {
      // 제목 주석
      lines.push(
        `# ${rarity.type} Leveling Armour (${ruleIdPrefix}-${rarity.id})`
      );

      // RID 주석
      lines.push(
        `# [RID: ${ruleIdPrefix}-${armourType.toLowerCase()}-${rarity.id}]`
      );

      // Show
      lines.push("Show");

      // BaseArmour 조건
      lines.push(`  BaseArmour ${conditions.baseArmour}`);

      // BaseEvasion 조건
      lines.push(`  BaseEvasion ${conditions.baseEvasion}`);

      // BaseEnergyShield 조건
      lines.push(`  BaseEnergyShield ${conditions.baseEnergyShield}`);

      // AreaLevel 조건
      lines.push("  AreaLevel <= 65");

      // Class 조건 (방어구 클래스들)
      lines.push(`  Class == ${armourClasses}`);

      // Rarity 조건
      lines.push(`  Rarity == ${rarity.type}`);

      // 스타일 (예시: White 효과)
      lines.push("  PlayEffect White");
      lines.push("  MinimapIcon 2 White Kite");

      lines.push("");
    });
  });
}

/**
 * 레벨링 전체 무기/방어구 규칙 생성 (장신구 제외)
 */
function generateLevelingAllGearRule(lines, levelingClassSelection, ruleIdPrefix) {
  const allGearClasses = [
    "Bows",
    "Crossbows",
    "Spears",
    "Talismans",
    "Quarterstaves",
    "Sceptres",
    "Wands",
    "Staves",
    "Quivers",
    "One Hand Maces",
    "Two Hand Maces",
    "Foci",
    "Body Armours",
    "Boots",
    "Gloves",
    "Helmets",
    "Shields",
    "Bucklers",
  ]
    .map((name) => `"${name}"`)
    .join(" ");

  const rarityTypes = [];
  if (levelingClassSelection.rarity.rare) {
    rarityTypes.push({ type: "Rare", id: "rare" });
  }
  if (levelingClassSelection.rarity.magic) {
    rarityTypes.push({ type: "Magic", id: "magic" });
  }
  if (levelingClassSelection.rarity.normal) {
    rarityTypes.push({ type: "Normal", id: "normal" });
  }

  if (rarityTypes.length === 0) return;

  rarityTypes.forEach((rarity) => {
    lines.push(`# ${rarity.type} Leveling Gear (${ruleIdPrefix}-${rarity.id})`);
    lines.push(`# [RID: ${ruleIdPrefix}-${rarity.id}]`);
    lines.push("Show");
    lines.push("  AreaLevel <= 65");
    lines.push(`  Class == ${allGearClasses}`);
    lines.push(`  Rarity == ${rarity.type}`);
    lines.push("  PlayEffect White");
    lines.push("  MinimapIcon 2 White Kite");
    lines.push("");
  });
}

// 모드 티어 규칙 생성
function generateModRules(lines, customModsTiers, soundContext, excludedItemsList = [], lang = "ko") {
  if (!modsTiersData || !modsTiersData.groups) return;

  lines.push("############################################################");
  lines.push(lang === "ko" ? "## 모드 티어 (커스텀 하이라이트)" : "## Mod Tiers (Custom Highlight)");
  lines.push("############################################################");

  // 티어별로 처리 (A부터 순서대로)
  ["A", "B", "C"].forEach(tier => {
    // 해당 티어에 속하는 모드 그룹들 찾기
    let groupIds = modsTiersData[tier] || [];

    // 커스텀 티어 반영 (다른 티어에서 이 티어로 이동해온 모드들)
    Object.keys(customModsTiers).forEach(modId => {
      if (customModsTiers[modId] === tier && !groupIds.includes(modId)) {
        groupIds.push(modId);
      }
    });

    // 이 티어에서 다른 티어로 이동한 모드 그룹 제외
    // 그리고 excludedItemsList에 있는 모드 그룹 제외
    const finalGroupIds = groupIds.filter(modId => {
      const customTier = customModsTiers[modId];
      return (!customTier || customTier === tier) && !excludedItemsList.includes(modId);
    });

    if (finalGroupIds.length === 0) return;

    lines.push(`# Mod Tier ${tier}`);
    
    finalGroupIds.forEach(groupId => {
      const modGroup = modsTiersData.groups?.[groupId];
      if (!modGroup) return;

      // 해당 그룹의 모든 티어 이름을 가져옴 (사용자가 "Crystalising" 같은 이름을 원함)
      const tierNames = modGroup.tiers.map(t => `"${t.nameEn}"`).join(" ");
      
      lines.push("Show");
      lines.push(`    HasExplicitMod ${tierNames}`);
      
      // 티어별 스타일 적용
      const styles = getModTierStyles(tier);
      if (styles.fontSize) lines.push(`    SetFontSize ${styles.fontSize}`);
      if (styles.textColor) lines.push(`    SetTextColor ${styles.textColor}`);
      if (styles.backgroundColor) lines.push(`    SetBackgroundColor ${styles.backgroundColor}`);
      if (styles.borderColor) lines.push(`    SetBorderColor ${styles.borderColor}`);
      
      // 사운드 처리
      if (!soundContext.isSilent) {
        if (tier === "A") {
          lines.push("    PlayAlertSound 1 300");
          lines.push("    PlayEffect Red");
          lines.push("    MinimapIcon 0 Red Star");
        } else if (tier === "B") {
          lines.push("    PlayAlertSound 2 300");
          lines.push("    PlayEffect Orange");
          lines.push("    MinimapIcon 1 Orange Circle");
        }
      }
    });
    lines.push("");
  });
}

// 모드 티어별 스타일 정의
function getModTierStyles(tier) {
  switch (tier) {
    case "S":
      return { fontSize: 45, textColor: "255 0 0", borderColor: "255 0 0", backgroundColor: "255 255 255 200" };
    case "A":
      return { fontSize: 40, textColor: "255 128 0", borderColor: "255 128 0" };
    case "B":
      return { fontSize: 35, textColor: "255 255 0", borderColor: "255 255 0" };
    case "C":
      return { fontSize: 30, textColor: "200 200 200" };
    default:
      return { fontSize: 32 };
  }
}

/**
 * 미가공 젬 규칙 생성
 */
function generateUncutGemsRules(lines, uncutGemsSettings, soundContext, lang = "ko") {
  const { isSndEnabled } = soundContext;
  if (uncutGemsSettings.enabled === false) {
    return;
  }

  uncutGemsSettings.rules.forEach((rule) => {
    if (!rule.enabled) {
      return;
    }

    // 제목 주석
    const title = lang === "ko" ? rule.nameKo || rule.name : rule.name;
    lines.push(`# ${title}`);

    // RID 주석
    lines.push(`# [RID: ${rule.id}]`);

    // Show
    lines.push(rule.type === "hide" ? "Hide" : "Show");

    // Class 조건
    if (rule.conditions?.class) {
      const classValue = rule.conditions.class.value;
      if (Array.isArray(classValue)) {
        const classes = classValue.map((c) => `"${c}"`).join(" ");
        lines.push(`  Class == ${classes}`);
      } else {
        lines.push(`  Class == "${classValue}"`);
      }
    }

    // BaseType 조건
    if (rule.conditions?.baseType) {
      const baseTypeValue = rule.conditions.baseType.value;
      if (Array.isArray(baseTypeValue)) {
        const baseTypes = baseTypeValue.map((b) => `"${b}"`).join(" ");
        lines.push(`  BaseType == ${baseTypes}`);
      } else {
        lines.push(`  BaseType == "${baseTypeValue}"`);
      }
    }

    // AreaLevel 조건
    if (rule.conditions?.areaLevel) {
      const { operator, value } = rule.conditions.areaLevel;
      lines.push(`  AreaLevel ${operator} ${value}`);
    }

    // 스타일 적용
    if (rule.type === "show" && rule.styles) {
      const styles = rule.styles;

      if (styles.fontSize) {
        lines.push(`  SetFontSize ${styles.fontSize}`);
      }

      if (styles.textColor) {
        const { r, g, b, a } = styles.textColor;
        lines.push(`  SetTextColor ${r} ${g} ${b} ${a}`);
      }

      if (styles.borderColor) {
        const { r, g, b, a } = styles.borderColor;
        lines.push(`  SetBorderColor ${r} ${g} ${b} ${a}`);
      }

      if (styles.backgroundColor) {
        const { r, g, b, a } = styles.backgroundColor;
        lines.push(`  SetBackgroundColor ${r} ${g} ${b} ${a}`);
      }

      if (styles.playEffect) {
        lines.push(`  PlayEffect ${styles.playEffect}`);
      }

      if (styles.minimapIcon) {
        const { size, color, shape } = styles.minimapIcon;
        if (size !== null || color !== null || shape !== null) {
          lines.push(`  MinimapIcon ${size || 0} ${color || "White"} ${shape || "Circle"}`);
        }
      }

      if (styles.playAlertSound) {
        const { id, volume } = styles.playAlertSound;
        if (id !== undefined && id !== null) {
          lines.push(`  PlayAlertSound ${id} ${volume || 300}`);
        }
      }

      if (styles.customSound && isSndEnabled(styles)) {
        if (/^\d+\s+\d+$/.test(styles.customSound)) {
          const [id, vol] = styles.customSound.split(" ");
          lines.push(`  PlayAlertSound ${id} ${vol}`);
        } else {
          const cs = styles.customSound.startsWith("custom_sound/") ? styles.customSound : `custom_sound/${styles.customSound}`;
          lines.push(`  CustomAlertSound "${cs}" 300`);
        }
      }
    }

    lines.push("");
  });
}
/**
 * 베이스 아이템 규칙 생성 (목걸이/반지/벨트 등)
 */
function generateBaseItemsRules(lines, baseItemsSettings, soundContext, lang = "ko") {
  const { isSndEnabled } = soundContext;
  if (baseItemsSettings.enabled === false) {
    return;
  }

  baseItemsSettings.rules.forEach((rule) => {
    if (!rule.enabled) {
      return;
    }

    // jewellery 규칙만 처리 (다른 규칙은 기존 gear 규칙에서 처리)
    if (rule.id !== "base_items_jewellery") {
      return;
    }

    // 제목 주석
    const title = lang === "ko" ? rule.nameKo || rule.name : rule.name;
    lines.push(`# ${title}`);

    // 규칙 ID 주석
    lines.push(`# [RID: Jewellery_]`);

    // Show/Hide
    lines.push(rule.type === "hide" ? "Hide" : "Show");

    // UnidentifiedItemTier 조건
    if (rule.conditions?.unidentifiedItemTier) {
      const { operator, value } = rule.conditions.unidentifiedItemTier;
      lines.push(`  UnidentifiedItemTier ${operator} ${value}`);
    }

    // Class 조건
    if (rule.conditions?.class) {
      const classValue = rule.conditions.class.value;
      if (Array.isArray(classValue)) {
        const classes = classValue.map(c => `"${c}"`).join(" ");
        lines.push(`  Class ${classes}`);
      } else {
        lines.push(`  Class "${classValue}"`);
      }
    }

    // itemTier 조건에 따른 BaseType 필터링
    if (rule.conditions?.itemTier?.value && rule.conditions.itemTier.value !== "all") {
      const tier = rule.conditions.itemTier.value;
      // T1/T2 목걸이/반지/벨트 베이스 타입 목록
      const tierBaseTypes = {
        "T1": ["Gold Amulet", "Lunar Amulet", "Ruby Ring", "Emerald Ring", "Iron Ring", "Prismatic Ring", "Plate Belt", "Mail Belt"],
        "T2": ["Amber Amulet", "Bloodstone Amulet", "Jade Tiara", "Sapphire Ring", "Topaz Ring", "Fine Belt", "Linen Belt"]
      };
      
      if (tierBaseTypes[tier]) {
        const bases = tierBaseTypes[tier].map(b => `"${b}"`).join(" ");
        lines.push(`  BaseType ${bases}`);
      }
    }

    // Rarity 조건
    if (rule.conditions?.rarity) {
      const { operator, value } = rule.conditions.rarity;
      if (operator === ">=" && value === "Normal") {
        lines.push(`  Rarity Normal Magic Rare`);
      } else if (operator === ">=") {
        lines.push(`  Rarity ${operator} ${value}`);
      } else {
        lines.push(`  Rarity ${value}`);
      }
    }

    // 스타일 적용
    const styles = rule.styles || {};
    
    if (styles.fontSize) {
      lines.push(`  SetFontSize ${styles.fontSize}`);
    }
    if (styles.textColor) {
      const { r, g, b, a } = styles.textColor;
      lines.push(`  SetTextColor ${r} ${g} ${b} ${a}`);
    }
    if (styles.borderColor) {
      const { r, g, b, a } = styles.borderColor;
      lines.push(`  SetBorderColor ${r} ${g} ${b} ${a}`);
    }
    if (styles.backgroundColor) {
      const { r, g, b, a } = styles.backgroundColor;
      lines.push(`  SetBackgroundColor ${r} ${g} ${b} ${a}`);
    }
    if (styles.playEffect) {
      lines.push(`  PlayEffect ${styles.playEffect}`);
    }
    if (styles.minimapIcon) {
      const { size, color, shape } = styles.minimapIcon;
      if (size !== null && size !== undefined) {
        lines.push(`  MinimapIcon ${size} ${color || "Orange"} ${shape || "Kite"}`);
      }
    }
    if (styles.playAlertSound && isSndEnabled(styles)) {
      const { id, volume } = styles.playAlertSound;
      lines.push(`  PlayAlertSound ${id} ${volume}`);
    }
    if (styles.customSound && isSndEnabled(styles)) {
      const cs = styles.customSound.startsWith("custom_sound/") ? styles.customSound : `custom_sound/${styles.customSound}`;
      lines.push(`  CustomAlertSound "${cs}"`);
      if (styles.soundVolume) {
        lines.push(`  CustomAlertSoundOptional ${styles.soundVolume}`);
      }
    }

    lines.push("");
  });
}

/**
 * 베이스 아이템 (소켓 & 퀄리티) 규칙 생성
 */
function generateBaseItemsSocketQualityRules(lines, settings, soundContext, lang = "ko") {
  const { isSndEnabled } = soundContext;
  if (settings.enabled === false) {
    return;
  }

  // 티어별 베이스 아이템 데이터 (소켓 규칙용)
  // 1소켓 > 2소켓 아이템 클래스
  const socket2Classes = ["Foci", "One Hand Maces", "Sceptres", "Spears", "Wands", "Helmets", "Gloves", "Boots", "Shields", "Bucklers"];
  // 2소켓 > 3소켓 아이템 클래스
  const socket3Classes = ["Body Armours", "Bows", "Crossbows", "Quarterstaves", "Staves", "Two Hand Maces"];

  // 티어별 베이스 타입 (무기/방어구)
  const tierBaseTypes = {
    "T1": {
      "Foci": [
        "Sacred Focus",
        "Tasalian Focus"
      ],
      "One Hand Maces": [
        "Akoyan Club",
        "Fortified Hammer",
        "Marauding Mace",
        "Strife Pick"
      ],
      "Sceptres": [
        "Omen Sceptre",
        "Rattling Sceptre",
        "Wrath Sceptre"
      ],
      "Spears": [
        "Akoyan Spear",
        "Guardian Spear",
        "Soaring Spear",
        "Spiked Spear"
      ],
      "Wands": [
        "Attuned Wand",
        "Dueling Wand",
        "Galvanic Wand",
        "Siphoning Wand",
        "Withered Wand"
      ],
      "Body Armours": [
        "Austere Garb",
        "Conjurer Mantle",
        "Corsair Coat",
        "Dastard Armour",
        "Death Mail",
        "Death Mantle",
        "Falconer's Jacket",
        "Feathered Raiment",
        "Flowing Raiment",
        "Ornate Plate",
        "Rambler Jacket",
        "Sacramental Robe",
        "Sacrificial Regalia",
        "Seastorm Mantle",
        "Shrouded Mail",
        "Sleek Jacket",
        "Slipstrike Vest",
        "Soldier Cuirass",
        "Swiftstalker Coat",
        "Thane Mail",
        "Utzaal Cuirass",
        "Vile Robe",
        "Warlord Cuirass",
        "Wolfskin Mantle",
        "Wyrmscale Coat"
      ],
      "Bows": [
        "Gemini Bow",
        "Guardian Bow",
        "Obliterator Bow",
        "Warmonger Bow"
      ],
      "Crossbows": [
        "Desolate Crossbow",
        "Elegant Crossbow",
        "Flexed Crossbow",
        "Gemini Crossbow",
        "Siege Crossbow"
      ],
      "Quarterstaves": [
        "Aegis Quarterstaff",
        "Dreaming Quarterstaff",
        "Skullcrusher Quarterstaff",
        "Striking Quarterstaff"
      ],
      "Talismans": [
        "Alpha Talisman",
        "Ashbark Talisman",
        "Fang Talisman",
        "Fungal Talisman",
        "Jade Talisman",
        "Maji Talisman",
        "Spiny Talisman",
        "Thunder Talisman",
        "Wildwood Talisman"
      ],
      "Staves": [
        "Chiming Staff",
        "Paralysing Staff",
        "Sanctified Staff",
        "Voltaic Staff"
      ],
      "Two Hand Maces": [
        "Fanatic Greathammer",
        "Ironwood Greathammer",
        "Massive Greathammer",
        "Tawhoan Greatclub"
      ],
      "Helmets": [
        "Ancestral Tiara",
        "Cryptic Crown",
        "Freebooter Cap",
        "Gladiatorial Helm",
        "Grinning Mask",
        "Imperial Greathelm"
      ],
      "Gloves": [
        "Adherent Cuffs",
        "Blacksteel Gauntlets",
        "Massive Mitts",
        "Polished Bracers",
        "Secured Wraps",
        "Sirenscale Gloves"
      ],
      "Boots": [
        "Blacksteel Sabatons",
        "Cryptic Leggings",
        "Daggerfoot Shoes",
        "Drakeskin Boots",
        "Sekhema Sandals",
        "Tasalian Greaves"
      ],
      "Shields": [
        "Blacksteel Crest Shield",
        "Golden Targe",
        "Tawhoan Tower Shield"
      ],
      "Bucklers": [
        "Desert Buckler"
      ]
    },
    "T2": {
      "Foci": [
        "Druidic Focus",
        "Leyline Focus"
      ],
      "One Hand Maces": [
        "Crown Mace",
        "Flanged Mace",
        "Molten Hammer"
      ],
      "Sceptres": [
        "Shrine Sceptre",
        "Stoic Sceptre"
      ],
      "Spears": [
        "Flying Spear",
        "Grand Spear",
        "Orichalcum Spear",
        "Pronged Spear",
        "Stalking Spear"
      ],
      "Wands": [
        "Bone Wand",
        "Volatile Wand"
      ],
      "Body Armours": [],
      "Bows": [
        "Cavalry Bow",
        "Fanatic Bow",
        "Ironwood Shortbow",
        "Twin Bow"
      ],
      "Crossbows": [
        "Engraved Crossbow",
        "Stout Crossbow"
      ],
      "Quarterstaves": [
        "Bolting Quarterstaff",
        "Lunar Quarterstaff",
        "Razor Quarterstaff",
        "Sinister Quarterstaff"
      ],
      "Talismans": [],
      "Staves": [
        "Ashen Staff",
        "Gelid Staff",
        "Pyrophyte Staff",
        "Reaping Staff",
        "Roaring Staff"
      ],
      "Two Hand Maces": [
        "Anvil Maul",
        "Ruination Maul",
        "Sacred Maul"
      ],
      "Helmets": [],
      "Gloves": [],
      "Boots": [],
      "Shields": [],
      "Bucklers": [
        "Ancient Buckler",
        "Gutspike Buckler",
        "Ornate Buckler"
      ]
    }
  };

  // T1/T2 퀄리티 규칙용 티어별 베이스 타입
  const qualityTierBaseTypes = {
    "T1": ["Expert Archmage Vestment", "Expert Ringmail", "Expert Knight Plate", "Expert Leathers", "Expert Brigandine", "Expert Lamellar", "Expert Mallet", "Expert Breaker", "Expert Sceptre", "Expert Osseous Sceptre", "Expert Spear", "Expert Harpoon", "Expert Duellist Wand", "Expert Surge Wand", "Expert Recurve Bow", "Expert Longbow", "Expert Arbalest", "Expert Dyad Crossbow", "Expert Ironhead Quarterstaff", "Expert Bladed Quarterstaff", "Expert Crescent Staff", "Expert Bifrost Staff", "Expert Greathammer", "Expert Stone Greathammer"],
    "T2": ["Advanced Archmage Vestment", "Advanced Ringmail", "Advanced Knight Plate", "Advanced Leathers", "Advanced Brigandine", "Advanced Lamellar", "Advanced Mallet", "Advanced Breaker", "Advanced Sceptre", "Advanced Osseous Sceptre", "Advanced Spear", "Advanced Harpoon", "Advanced Duellist Wand", "Advanced Surge Wand", "Advanced Recurve Bow", "Advanced Longbow", "Advanced Arbalest", "Advanced Dyad Crossbow", "Advanced Ironhead Quarterstaff", "Advanced Bladed Quarterstaff", "Advanced Crescent Staff", "Advanced Bifrost Staff", "Advanced Greathammer", "Advanced Stone Greathammer"]
  };

  settings.rules.forEach((rule) => {
    if (!rule.enabled) {
      return;
    }

    // 제목 주석
    const title = lang === "ko" ? rule.nameKo || rule.name : rule.name;
    lines.push(`# ${title}`);

    // 규칙 ID 주석
    lines.push(`# [RID: ${rule.id}]`);

    // Show/Hide
    lines.push(rule.type === "hide" ? "Hide" : "Show");

    // 소켓 규칙인지 퀄리티 규칙인지 확인
    const isSocketRule = rule.id.includes("socketed");
    const isQualityRule = rule.id.includes("quality");

    // 소켓 조건
    if (rule.conditions?.sockets) {
      const { operator, value } = rule.conditions.sockets;
      lines.push(`  Sockets ${operator} ${value}`);
    }

    // 퀄리티 조건
    if (rule.conditions?.quality) {
      const { operator, value } = rule.conditions.quality;
      lines.push(`  Quality ${operator} ${value}`);
    }

    // Class 조건 (소켓 규칙)
    if (isSocketRule && rule.conditions?.class) {
      const classValue = rule.conditions.class.value;
      if (Array.isArray(classValue)) {
        const classes = classValue.map(c => `"${c}"`).join(" ");
        lines.push(`  Class == ${classes}`);
      } else {
        lines.push(`  Class == "${classValue}"`);
      }
    }

    // BaseType 조건 - 티어에 따라 다른 베이스 타입 적용
    const tierValue = rule.conditions?.itemTier?.value || "T1";
    
    if (isSocketRule) {
      // 소켓 규칙: 티어와 클래스에 따른 베이스 타입
      if (tierValue !== "all") {
        const classes = rule.conditions?.class?.value || [];
        let allBases = [];
        
        classes.forEach(cls => {
          const bases = tierBaseTypes[tierValue]?.[cls] || [];
          allBases = allBases.concat(bases);
        });
        
        if (allBases.length > 0) {
          const basesStr = allBases.map(b => `"${b}"`).join(" ");
          lines.push(`  BaseType == ${basesStr}`);
        }
      }
    } else if (isQualityRule && (rule.conditions?.itemTier || rule.conditions?.class || rule.conditions?.levelType)) {
      // 퀄리티 규칙: 티어에 따른 베이스 타입
      // levelType에 따라 MIN_ILVL 또는 CAP_ILVL 적용
      const levelType = rule.conditions?.levelType?.value || "MIN_ILVL";
      
      // 무기/방어구 클래스 목록
      lines.push(`  Class "Body Armours" "Helmets" "Gloves" "Boots" "Bows" "Crossbows" "Quarterstaves" "Staves" "Two Hand Maces" "One Hand Maces" "Sceptres" "Spears" "Wands" "Foci"`);
      
      // 티어에 따른 베이스 타입 추가
      if (tierValue !== "all") {
        const tierData = tierBaseTypes[tierValue];
        if (tierData) {
          // 해당 티어의 모든 베이스 타입 수집
          const allBases = Object.values(tierData).flat();
          if (allBases.length > 0) {
            const basesStr = allBases.map(b => `"${b}"`).join(" ");
            lines.push(`  BaseType == ${basesStr}`);
          }
        }
      }
    }

    // AreaLevel 조건
    if (rule.conditions?.areaLevel) {
      const { operator, value } = rule.conditions.areaLevel;
      lines.push(`  AreaLevel ${operator} ${value}`);
    }

    // Rarity 조건
    if (rule.conditions?.rarity) {
      const { operator, value } = rule.conditions.rarity;
      if (operator === "==" && value === "Normal") {
        lines.push(`  Rarity == Normal`);
      } else if (operator === ">=") {
        lines.push(`  Rarity >= ${value}`);
      } else {
        lines.push(`  Rarity ${operator} ${value}`);
      }
    }

    // 스타일 적용
    const styles = rule.styles || {};
    
    if (styles.fontSize) {
      lines.push(`  SetFontSize ${styles.fontSize}`);
    }
    if (styles.textColor) {
      const { r, g, b, a } = styles.textColor;
      lines.push(`  SetTextColor ${r} ${g} ${b} ${a}`);
    }
    if (styles.borderColor) {
      const { r, g, b, a } = styles.borderColor;
      lines.push(`  SetBorderColor ${r} ${g} ${b} ${a}`);
    }
    if (styles.backgroundColor) {
      const { r, g, b, a } = styles.backgroundColor;
      lines.push(`  SetBackgroundColor ${r} ${g} ${b} ${a}`);
    }
    if (styles.playEffect) {
      lines.push(`  PlayEffect ${styles.playEffect}`);
    }
    if (styles.minimapIcon) {
      const { size, color, shape } = styles.minimapIcon;
      if (size !== null && size !== undefined) {
        lines.push(`  MinimapIcon ${size} ${color || "Red"} ${shape || "Kite"}`);
      }
    }
    if (styles.playAlertSound && isSndEnabled(styles)) {
      const { id, volume } = styles.playAlertSound;
      lines.push(`  PlayAlertSound ${id} ${volume}`);
    }
    if (styles.customSound && isSndEnabled(styles)) {
      const cs = styles.customSound.startsWith("custom_sound/") ? styles.customSound : `custom_sound/${styles.customSound}`;
      lines.push(`  CustomAlertSound "${cs}"`);
      if (styles.soundVolume) {
        lines.push(`  CustomAlertSoundOptional ${styles.soundVolume}`);
      }
    }

    lines.push("");
  });
}

/**
 * 감정된 무기 규칙 생성
 */
function generateIdentifiedWeaponsRules(lines, settings, soundContext, lang = "ko") {
  const { isSndEnabled } = soundContext;
  if (settings.enabled === false) {
    return;
  }

  // 모드 리스트 정의
  const physPrefixes = ["Dictator's", "Emperor's", "Flaring", "Merciless", "Tempered", "Tyrannical"];
  const physSuffixes = ["of Celebration", "of Destruction", "of Infamy", "of Unmaking", "of the Desperate", "of the Vampire"];
  const physCombined = [...physPrefixes, ...physSuffixes, "Conqueror's", "Cruel", "Razor-sharp", "of Calamity", "of Fame", "of Ferocity", "of Fury", "of Ruin", "of the Drought", "of the Lamprey"];
  const badMods = ["Arcing", "Blasting", "Burning", "Burnished", "Buzzing", "Catalysing", "Chilled", "Crackling", "Discharging", "Empowering", "Flaming", "Freezing", "Frigid", "Frosted", "Frozen", "Glaciated", "Glinting", "Heated", "Heavy", "Humming", "Icy", "Incinerating", "Infusing", "Journeyman's", "Overpowering", "Polar", "Polished", "Reaver's", "Scorching", "Serrated", "Shocking", "Smoking", "Smouldering", "Snapping", "Sparking", "Squire's", "Unleashed", "Wicked", "of Absorption", "of Conquest", "of Consumption", "of Dazing", "of Ease", "of Enveloping", "of Impact", "of Infusion", "of Ire", "of Mastery", "of Menace", "of Osmosis", "of Regrowth", "of Rejuvenation", "of Restoration", "of Siphoning", "of Skill", "of Slamming", "of Staggering" , "of Stunning", "of Success", "of Triumph", "of Valour", "of Vanquishing", "of Victory", "of the Apt", "of the Concussion", "of the Skilled", "of the Talented", "of the Worthy"];

  const elemPrefixes = ["Arcing", "Blasting", "Burning", "Burnished", "Buzzing", "Catalysing", "Chilled", "Crackling", "Discharging", "Empowering", "Flaming", "Freezing", "Frigid", "Frosted", "Frozen", "Glaciated", "Glinting", "Heated", "Heavy", "Humming", "Icy", "Incinerating", "Infusing", "Journeyman's", "Overpowering", "Polar", "Polished", "Reaver's", "Scorching", "Serrated", "Shocking", "Smoking", "Smouldering", "Snapping", "Sparking", "Squire's", "Unleashed", "Wicked"];
  const elemCombined = [...elemPrefixes, ...physSuffixes, "of Absorption", "of Acquisition", "of Aggression", "of Alacrity", "of Aptitude", "of Assailing", "of Celerity", "of Consumption", "of Ease", "of Impact", "of Infusion", "of Ire", "of Mastery", "of Menace", "of Might", "of Osmosis", "of Potency", "of Prowess", "of Readiness", "of Rejuvenation", "of Restoration", "of Siphoning", "of Skill", "of Slamming", "of Staggering", "of Stunning", "of Success", "of Tenacity", "of Triumph", "of Valour", "of Vanquishing", "of Victory", "of the Apt", "of the Skilled", "of the Talented", "of the Worthy"];
  const physModsOnly = ["Conqueror's", "Cruel", "Dictator's", "Emperor's", "Flaring", "Merciless", "Razor-sharp", "Tempered", "Tyrannical"];

  const commonClasses = ["Bows", "Crossbows", "Spears", "Talismans", "One Hand Maces", "Quarterstaves", "Two Hand Maces"];
  const commonBaseTypes = ["Artillery Bow", "Tribal Bow", "Adherent Bow", "Militant Bow", "Blackfire Crossbow", "Piercing Crossbow", "Twin Crossbow", "Cannonade Crossbow", "Bleak Crossbow", "Morning Star", "Jade Club", "Kalguuran Forgehammer", "Marching Mace", "Bandit Mace", "Structured Hammer", "Hefty Quarterstaff", "Smooth Quarterstaff", "Waxing Quarterstaff", "Bladed Quarterstaff", "Guardian Quarterstaff", "Branched Spear", "Jagged Spear", "Massive Spear", "Voltfang Talisman", "Lumbering Talisman", "Howling Talisman", "Roaring Talisman", "Fury Talisman", "Cruel Talisman", "Condemned Talisman", "Wingbeat Talisman", "Pointed Maul", "Totemic Greatclub", "Solemn Maul", "Heavy Greathammer", "Disintegrating Maul", "Twin Bow", "Ironwood Shortbow", "Cavalry Bow", "Fanatic Bow", "Stout Crossbow", "Engraved Crossbow", "Flanged Mace", "Crown Mace", "Molten Hammer", "Sinister Quarterstaff", "Lunar Quarterstaff", "Bolting Quarterstaff", "Razor Quarterstaff", "Orichalcum Spear", "Pronged Spear", "Stalking Spear", "Flying Spear", "Grand Spear", "Anvil Maul", "Sacred Maul", "Ruination Maul", "Guardian Bow", "Gemini Bow", "Warmonger Bow", "Obliterator Bow", "Flexed Crossbow", "Gemini Crossbow", "Siege Crossbow", "Desolate Crossbow", "Elegant Crossbow", "Strife Pick", "Fortified Hammer", "Marauding Mace", "Akoyan Club", "Striking Quarterstaff", "Aegis Quarterstaff", "Dreaming Quarterstaff", "Skullcrusher Quarterstaff", "Spiked Spear", "Akoyan Spear", "Soaring Spear", "Guardian Spear", "Spiny Talisman", "Wildwood Talisman", "Ashbark Talisman", "Alpha Talisman", "Thunder Talisman", "Fang Talisman", "Jade Talisman", "Fungal Talisman", "Maji Talisman", "Ironwood Greathammer", "Fanatic Greathammer", "Massive Greathammer", "Tawhoan Greatclub"];

  settings.rules.forEach((rule) => {
    if (!rule.enabled) return;

    lines.push(`# ${lang === "ko" ? rule.nameKo : rule.name}`);
    lines.push(`# [RID: ${rule.id}]`);
    lines.push("Show");
    if (staticIdentifiedRules[rule.id]) {
      lines.push(...staticIdentifiedRules[rule.id]);
      lines.push("");
      return;
    }
    lines.push("    Identified True");
    lines.push(`    Class == ${commonClasses.map(c => `"${c}"`).join(" ")}`);
    lines.push(`    BaseType == ${commonBaseTypes.map(b => `"${b}"`).join(" ")}`);
    lines.push("    Corrupted False");

    if (rule.id.includes("physical")) {
      if (rule.id.endsWith("_a")) {
        lines.push(`    HasExplicitMod >=1 ${physPrefixes.map(m => `"${m}"`).join(" ")}`);
        lines.push(`    HasExplicitMod >=1 ${physSuffixes.map(m => `"${m}"`).join(" ")}`);
        lines.push(`    HasExplicitMod >=4 ${physCombined.map(m => `"${m}"`).join(" ")}`);
        lines.push(`    HasExplicitMod =0 ${badMods.map(m => `"${m}"`).join(" ")}`);
      } else {
        lines.push(`    HasExplicitMod >=1 ${[...physPrefixes, ...physSuffixes].map(m => `"${m}"`).join(" ")}`);
        lines.push(`    HasExplicitMod >=3 ${physCombined.map(m => `"${m}"`).join(" ")}`);
        lines.push(`    HasExplicitMod <=1 ${badMods.map(m => `"${m}"`).join(" ")}`);
      }
    } else if (rule.id.includes("elemental")) {
      if (rule.id.endsWith("_a")) {
        lines.push(`    HasExplicitMod >=2 ${elemPrefixes.map(m => `"${m}"`).join(" ")}`);
        lines.push(`    HasExplicitMod >=1 ${physSuffixes.map(m => `"${m}"`).join(" ")}`);
        lines.push(`    HasExplicitMod >=4 ${elemCombined.map(m => `"${m}"`).join(" ")}`);
        lines.push(`    HasExplicitMod =0 ${physModsOnly.map(m => `"${m}"`).join(" ")}`);
      } else {
        lines.push(`    HasExplicitMod >=1 ${[...elemPrefixes, ...physSuffixes].map(m => `"${m}"`).join(" ")}`);
        lines.push(`    HasExplicitMod >=3 ${elemCombined.map(m => `"${m}"`).join(" ")}`);
        lines.push(`    HasExplicitMod <=1 ${physModsOnly.map(m => `"${m}"`).join(" ")}`);
      }
    }

    // 스타일 적용
    const styles = rule.styles || {};
    if (styles.fontSize) lines.push(`    SetFontSize ${styles.fontSize}`);
    if (styles.textColor) lines.push(`    SetTextColor ${styles.textColor.r} ${styles.textColor.g} ${styles.textColor.b} ${styles.textColor.a}`);
    if (styles.borderColor) lines.push(`    SetBorderColor ${styles.borderColor.r} ${styles.borderColor.g} ${styles.borderColor.b} ${styles.borderColor.a}`);
    if (styles.backgroundColor) lines.push(`    SetBackgroundColor ${styles.backgroundColor.r} ${styles.backgroundColor.g} ${styles.backgroundColor.b} ${styles.backgroundColor.a}`);
    if (styles.playEffect) lines.push(`    PlayEffect ${styles.playEffect}`);
    if (styles.minimapIcon) lines.push(`    MinimapIcon ${styles.minimapIcon.size} ${styles.minimapIcon.color} ${styles.minimapIcon.shape}`);
    if (styles.playAlertSound && isSndEnabled(styles)) lines.push(`    PlayAlertSound ${styles.playAlertSound.id} ${styles.playAlertSound.volume}`);
    if (styles.customSound && isSndEnabled(styles)) {
      const cs = styles.customSound.startsWith("custom_sound/") ? styles.customSound : `custom_sound/${styles.customSound}`;
      lines.push(`    CustomAlertSound "${cs}"`);
      if (styles.soundVolume) {
        lines.push(`    CustomAlertSoundOptional ${styles.soundVolume}`);
      }
    }

    lines.push("");
  });
}

/**
 * 감정된 시전 무기 규칙 생성 (지팡이, 마법봉, 셉터, 화살통)
 */
function generateIdentifiedCastingWeaponsRules(lines, settings, soundContext, lang = "ko") {
  const { isSndEnabled } = soundContext;
  if (settings.enabled === false) {
    return;
  }

  // 모드 리스트 정의
  const castingPrefixes = ["Adept's", "Brilliant", "Glimmering", "Glowing", "Luminous", "Radiant", "Resplendent"];
  const physPrefixes = ["Dictator's", "Emperor's", "Flaring", "Merciless", "Tempered", "Tyrannical"];
  const physSuffixes = ["of Celebration", "of Destruction", "of Infamy", "of Unmaking", "of the Desperate", "of the Vampire"];
  const castingCombined = [...castingPrefixes, ...physSuffixes, "Adept's", "Brilliant", "Glimmering", "Glowing", "Luminous", "Radiant", "Resplendent", "of Acquisition", "of Alacrity", "of Aptitude", "of Assailing", "of Celerity", "of Might", "of Potency", "of Prowess", "of Readiness", "of Tenacity"];
  const minionPrefixes = ["Invoker's", "Overlord's", "Puppeteer's", "Servant's", "Tamer's"];
  const minionCombined = [...minionPrefixes, ...physSuffixes, "of Acquisition", "of Alacrity", "of Aptitude", "of Assailing", "of Celerity", "of Might", "of Potency", "of Prowess", "of Readiness", "of Tenacity"];
  const elemPrefixes = ["Arcing", "Blasting", "Burning", "Burnished", "Buzzing", "Catalysing", "Chilled", "Crackling", "Discharging", "Empowering", "Flaming", "Freezing", "Frigid", "Frosted", "Frozen", "Glaciated", "Glinting", "Heated", "Heavy", "Humming", "Icy", "Incinerating", "Infusing", "Journeyman's", "Overpowering", "Polar", "Polished", "Reaver's", "Scorching", "Serrated", "Shocking", "Smoking", "Smouldering", "Snapping", "Sparking", "Squire's", "Unleashed", "Wicked"];
  const physCombined = [...physPrefixes, ...physSuffixes, "Conqueror's", "Cruel", "Razor-sharp", "of Calamity", "of Fame", "of Ferocity", "of Fury", "of Ruin", "of the Drought", "of the Lamprey"];

  settings.rules.forEach((rule) => {
    if (!rule.enabled) return;

    lines.push(`# ${lang === "ko" ? rule.nameKo : rule.name}`);
    lines.push(`# [RID: ${rule.id}]`);
    lines.push("Show");
    if (staticIdentifiedRules[rule.id]) {
      lines.push(...staticIdentifiedRules[rule.id]);
      lines.push("");
      return;
    }
    lines.push("    Identified True");
    lines.push("    Corrupted False");

    // Class & BaseType 조건 (아이템 타입별)
    if (rule.id.includes("chaos") || rule.id.includes("cold") || rule.id.includes("fire") || rule.id.includes("lightning") || rule.id.includes("casting_physical")) {
      lines.push('    Class == "Staves" "Wands"');
      lines.push('    BaseType == "Attuned Wand" "Siphoning Wand" "Withered Wand" "Torture Wand" "Volatile Wand" "Prying Wand" "Bone Wand" "Cursed Wand" "Chiming Staff" "Voltaic Staff" "Crescent Staff" "Rune Staff" "Vile Staff" "Long Staff" "Grand Wand" "Crackling Wand" "Gallant Staff" "Onyx Wand" "Auspicious Staff" "Simple Wand" "Ivory Wand" "Prowling Wand" "Fairy Wand" "Shadow Staff" "Gelid Staff" "Sprigwand" "Warped Staff" "Rusted Staff" "Desert Staff" "Fine Staff" "Expert Luminous Wand" "Expert Primal Staff" "Expert Siphoning Wand" "Expert Rune Staff" "Expert Withered Wand" "Expert Vile Staff" "Expert Attuned Wand" "Expert Crescent Staff" "Expert Chiming Staff"');
    } else if (rule.id.includes("minion")) {
      lines.push('    Class == "Sceptres"');
      lines.push('    BaseType == "Omen Sceptre" "Stoic Sceptre" "Cleric Sceptre" "Looming Sceptre" "Herald Sceptre" "Apep Sceptre" "Serrated Sceptre" "Wrath Sceptre" "Dread Sceptre" "Hollow Sceptre" "Ratten Sceptre" "Pious Sceptre" "Devouring Sceptre" "Stone Sceptre" "Lead Sceptre" "Driftwood Sceptre" "Expert Pious Sceptre" "Expert Omen Sceptre" "Expert Stoic Sceptre"');
    } else if (rule.id.includes("quiver")) {
      lines.push('    Class == "Quivers"');
      lines.push('    BaseType == "Visceral Quiver" "Two-Point Quiver" "Primal Quiver" "Pelican Quiver" "Fire Quiver" "Broadhead Quiver" "Serrated Quiver" "Sharp Quiver" "Volatile Quiver" "Heavy Quiver" "Cruel Quiver" "Sacred Quiver" "Twilight Quiver" "Wayfarer Quiver"');
    }

    // HasExplicitMod 조건 (대미지/타입별)
    if (rule.id.includes("chaos") || rule.id.includes("cold") || rule.id.includes("fire") || rule.id.includes("lightning") || rule.id.includes("casting_physical")) {
      lines.push(`    HasExplicitMod >=1 ${castingPrefixes.map(m => `"${m}"`).join(" ")}`);
      lines.push(`    HasExplicitMod >=1 ${physSuffixes.map(m => `"${m}"`).join(" ")}`);
      const count = rule.id.endsWith("_a") ? 4 : 3;
      lines.push(`    HasExplicitMod >=${count} ${castingCombined.map(m => `"${m}"`).join(" ")}`);
    } else if (rule.id.includes("minion")) {
      lines.push(`    HasExplicitMod >=1 ${minionPrefixes.map(m => `"${m}"`).join(" ")}`);
      lines.push(`    HasExplicitMod >=1 ${physSuffixes.map(m => `"${m}"`).join(" ")}`);
      const count = rule.id.endsWith("_a") ? 4 : 3;
      lines.push(`    HasExplicitMod >=${count} ${minionCombined.map(m => `"${m}"`).join(" ")}`);
    } else if (rule.id.includes("quivers_elemental")) {
      lines.push(`    HasExplicitMod >=2 ${elemPrefixes.map(m => `"${m}"`).join(" ")}`);
      lines.push(`    HasExplicitMod >=1 ${physSuffixes.map(m => `"${m}"`).join(" ")}`);
      const count = rule.id.endsWith("_a") ? 4 : 3;
      lines.push(`    HasExplicitMod >=${count} ${[...elemPrefixes, ...physSuffixes].map(m => `"${m}"`).join(" ")}`);
    } else if (rule.id.includes("quivers_physical")) {
      lines.push(`    HasExplicitMod >=1 ${physPrefixes.map(m => `"${m}"`).join(" ")}`);
      lines.push(`    HasExplicitMod >=1 ${physSuffixes.map(m => `"${m}"`).join(" ")}`);
      const count = rule.id.endsWith("_a") ? 4 : 3;
      lines.push(`    HasExplicitMod >=${count} ${physCombined.map(m => `"${m}"`).join(" ")}`);
    }

    // 스타일 적용
    const styles = rule.styles || {};
    if (styles.fontSize) lines.push(`    SetFontSize ${styles.fontSize}`);
    if (styles.textColor) lines.push(`    SetTextColor ${styles.textColor.r} ${styles.textColor.g} ${styles.textColor.b} ${styles.textColor.a}`);
    if (styles.borderColor) lines.push(`    SetBorderColor ${styles.borderColor.r} ${styles.borderColor.g} ${styles.borderColor.b} ${styles.borderColor.a}`);
    if (styles.backgroundColor) lines.push(`    SetBackgroundColor ${styles.backgroundColor.r} ${styles.backgroundColor.g} ${styles.backgroundColor.b} ${styles.backgroundColor.a}`);
    if (styles.playEffect) lines.push(`    PlayEffect ${styles.playEffect}`);
    if (styles.minimapIcon) lines.push(`    MinimapIcon ${styles.minimapIcon.size} ${styles.minimapIcon.color} ${styles.minimapIcon.shape}`);
    if (styles.playAlertSound && isSndEnabled(styles)) lines.push(`    PlayAlertSound ${styles.playAlertSound.id} ${styles.playAlertSound.volume}`);
    if (styles.customSound && isSndEnabled(styles)) {
      const cs = styles.customSound.startsWith("custom_sound/") ? styles.customSound : `custom_sound/${styles.customSound}`;
      lines.push(`    CustomAlertSound "${cs}"`);
      if (styles.soundVolume) {
        lines.push(`    CustomAlertSoundOptional ${styles.soundVolume}`);
      }
    }

    lines.push("");
  });
}

/**
 * 감정된 생명력 방어구 규칙 생성
 */
function generateIdentifiedLifeArmourRules(lines, settings, soundContext, lang = "ko") {
  const { isSndEnabled } = soundContext;
  if (settings.enabled === false) {
    return;
  }

  // 모드 리스트 정의
  const lifePrefixes = ["Adaptable", "Antelope's", "Apparition's", "Banshee's", "Centurion's", "Crocodile's", "Divine", "Duchess'", "Fugitive", "Godly", "Grand", "Hardened", "Illusion's", "Illusory", "Impenetrable", "Impervious", "Impregnable", "Incandescent", "Incorporeal", "Inspired", "Interpermeated", "Legend's", "Lissome", "Maestro's", "Mirage's", "Pope's", "Predator's", "Prime", "Princess'", "Prophet's", "Queen's", "Rapturous", "Resplendent", "Saintly", "Stag's", "Stalker's", "Unassailable", "Unfaltering", "Unmoving", "Versatile", "Victor's", "Vigorous"];
  const lifeSuffixes = ["of Anticipation", "of Bameth", "of Ephij", "of Exile", "of Haast", "of Magma", "of Thermokryptance", "of Tzteosh", "of Warping", "of the Ice", "of the Jaguar", "of the Leviathan", "of the Lightning", "of the Phantom", "of the Savant", "of the Titan", "of the Virtuoso"];
  const lifeCombined = [...lifePrefixes, ...lifeSuffixes, "Abating", "Adroit", "Aggressor's", "Archon's", "Assailant's", "Bard's", "Bishop's", "Caribou's", "Consecrated", "Countess'", "Dazzling", "Deer's", "Eidolon's", "Elusory", "Enveloped", "Exarch's", "Fecund", "Girded", "Haruspex's", "Hero's", "High Priest's", "Ibex's", "Indomitable", "Interpolated", "Knight's", "Minstrel's", "Nautilus'", "Nightmare's", "Octopus'", "Paladin's", "Pangolin's", "Phantom's", "Ram's", "Resilient", "Rogue's", "Scintillating", "Shelled", "Unreal", "Visionary's", "Warrior's", "of Diversion", "of Excitement", "of Expulsion", "of Flexure", "of Furring", "of Motivation", "of Padding", "of the Goliath", "of the Leopard", "of the Maelstrom", "of the Polar Bear", "of the Sage", "of the Volcano"];
  const badMods = ["Abalone's", "Acrobat's", "Agile", "Anointed", "Augur's", "Barbed", "Baronness'", "Blessed", "Brawler's", "Bully's", "Dancer's", "Deacon's", "Edged", "Ethereal", "Fencer's", "Flea's", "Fleet", "Flexible", "Fortified", "Ghost's", "Glimmering", "Glittering", "Glowing", "Hale", "Healthy", "Impala's", "Infixed", "Ingrained", "Instilled", "Jagged", "Lacquered", "Lady's", "Layered", "Lobstered", "Monk's", "Nymph's", "Oyster's", "Pliant", "Poet's", "Pointed", "Protective", "Pursuer's", "Reinforced", "Resolute", "Ribbed", "Sanctified", "Sanguine", "Scrapper's", "Shade's", "Shadowy", "Shining", "Spectre's", "Spiked", "Spiny", "Strong-Willed", "Studded", "Supple", "Swordsman's", "Sylph's", "Thorny", "Unworldly", "Will-o-wisp's", "of Convalescence", "of Covering", "of Deflecting", "of Impatience", "of Recuperation", "of Resurgence", "of the Apt", "of the Bear", "of the Brute", "of the Cloud", "of the Drake", "of the Flatworm", "of the Fox", "of the Hydra", "of the Lizard", "of the Lost", "of the Lynx", "of the Mongoose", "of the Narwhal", "of the Newt", "of the Penguin", "of the Prodigy", "of the Pupil", "of the Salamander", "of the Seal", "of the Skilled", "of the Squall", "of the Starfish", "of the Storm", "of the Student", "of the Talented", "of the Troll", "of the Whelpling", "of the Worthy", "of the Wrestler"];

  const shieldLifePrefixes = ["Abating", "Adamant", "Adaptable", "Adroit", "Apparition's", "Athlete's", "Fecund", "Illusion's", "Illusory", "Impenetrable", "Impregnable", "Incandescent", "Incorporeal", "Inspired", "Interpermeated", "Legend's", "Lissome", "Mirage's", "Saintly", "Scintillating", "Unfaltering", "Unmoving", "Victor's", "Vigorous"];
  const shieldLifeSuffixes = ["of Bameth", "of Ephij", "of Exile", "of Haast", "of Harmony", "of Magma", "of Suffusion", "of Thermokryptance", "of Tzteosh", "of Warping", "of the Conservator", "of the Everlasting", "of the Ice", "of the Jaguar", "of the Leviathan", "of the Lightning", "of the Lightning Rod", "of the Mammoth", "of the Phantom", "of the Savant", "of the Solar Storm", "of the Span", "of the Titan", "of the Virtuoso"];
  const shieldLifeCombined = [...shieldLifePrefixes, ...shieldLifeSuffixes, "Beatified", "Consecrated", "Dazzling", "Eidolon's", "Elusory", "Enveloped", "Girded", "Hero's", "Interpolated", "Nightmare's", "Resilient", "Spirit's", "Sturdy", "Unreal", "Unrelenting", "Virile", "of Ardour", "of Buffering", "of Concord", "of Diversion", "of Expulsion", "of Flexure", "of Furring", "of Padding", "of Shockproofing", "of Variegation", "of the Deathless", "of the Goliath", "of the Leopard", "of the Maelstrom", "of the Molten Core", "of the Polar Bear", "of the Protector", "of the Rainbow", "of the Sage", "of the Tundra", "of the Volcano"];
  const shieldBadMods = ["Acrobat's", "Agile", "Barbed", "Blessed", "Brawler's", "Dancer's", "Edged", "Ethereal", "Fencer's", "Ghost's", "Glimmering", "Glittering", "Hale", "Healthy", "Infixed", "Ingrained", "Instilled", "Jagged", "Lacquered", "Layered", "Lobstered", "Pointed", "Reinforced", "Ribbed", "Sanguine", "Scrapper's", "Shade's", "Shadowy", "Shining", "Spectre's", "Spiked", "Spiny", "Studded", "Supple", "Thorny", "Unworldly", "Will-o-wisp's", "of Covering", "of Deflecting", "of Enlivening", "of the Apt", "of the Bear", "of the Brute", "of the Cloud", "of the Crystal", "of the Drake", "of the Fox", "of the Lost", "of the Lynx", "of the Mongoose", "of the Narwhal", "of the Newt", "of the Penguin", "of the Prodigy", "of the Pupil", "of the Salamander", "of the Seal", "of the Skilled", "of the Squall", "of the Storm", "of the Student", "of the Talented", "of the Whelpling", "of the Worthy", "of the Wrestler"];

  const helmetLifePrefixes = ["Amazon's", "Ancestral", "Angel's", "Athlete's", "Beatified", "Blazing", "Cerberus'", "Crocodile's", "Dazzling", "Dragon's", "Elusory", "Encased", "Enveloped", "Falcon's", "Fecund", "Illusory", "Impregnable", "Inspired", "Legend's", "Maestro's", "Mirage's", "Pope's", "Predator's", "Prophet's", "Ranger's", "Spirit's", "Stag's", "Sturdy", "Unassailable", "Vaporous", "Virile", "Wanderer's", "Whale's"];
  const helmetLifeSuffixes = ["of Bameth", "of Buffering", "of Ephij", "of Exile", "of Flexure", "of Furring", "of Haast", "of Magma", "of Tzteosh", "of Windfall", "of the Genius", "of the Ice", "of the Jaguar", "of the Leviathan", "of the Lightning", "of the Phantom", "of the Titan", "of the Virtuoso"];
  const helmetLifeCombined = [...helmetLifePrefixes, ...helmetLifeSuffixes, "Aggressor's", "Assailant's", "Bard's", "Bishop's", "Bull's", "Carapaced", "Celestial", "Cherub's", "Chieftain's", "Colossal", "Dauntless", "Dolphin's", "Duelist's", "Durable", "Eagle's", "Evanescent", "Exarch's", "Explorer's", "Girded", "Hallowed", "Haruspex's", "Hawk's", "Heavenly", "Hero's", "Ibex's", "Inculcated", "Indomitable", "Interpolated", "Minotaur's", "Minstrel's", "Nautilus'", "Nightmare's", "Octopus'", "Orca's", "Phantasm's", "Phased", "Pirate's", "Pulsing", "Ram's", "Rotund", "Steady", "Thickened", "Unreal", "Visionary's", "Wayfarer's", "of Dispersal", "of Diversion", "of Excavation", "of Expulsion", "of Padding", "of the Goliath", "of the Leopard", "of the Maelstrom", "of the Polar Bear", "of the Savant", "of the Volcano"];
  const helmetBadMods = ["Acrobat's", "Agile", "Augur's", "Bully's", "Coelacanth's", "Dancer's", "Flea's", "Focused", "Glimmering", "Glittering", "Hale", "Healthy", "Imbued", "Imposing", "Infixed", "Lacquered", "Monk's", "Nomad's", "Oyster's", "Poet's", "Precise", "Protective", "Reinforced", "Reliable", "Rhoa's", "Ribbed", "Scrapper's", "Shade's", "Shadowy", "Shining", "Studded", "Vulture's", "of Light", "of Radiance", "of Shining", "of the Apt", "of the Bear", "of the Brute", "of the Cloud", "of the Drake", "of the Flatworm", "of the Fox", "of the Hydra", "of the Lizard", "of the Lost", "of the Lynx", "of the Mongoose", "of the Narwhal", "of the Newt", "of the Penguin", "of the Prodigy", "of the Pupil", "of the Salamander", "of the Seal", "of the Skilled", "of the Squall", "of the Starfish", "of the Storm", "of the Student", "of the Talented", "of the Troll", "of the Whelpling", "of the Worthy", "of the Wrestler"];

  const gloveLifePrefixes = ["Amazon's", "Athlete's", "Blasting", "Blazing", "Chalybeous", "Cherub's", "Cremating", "Crocodile's", "Discharging", "Durable", "Electrocuting", "Encased", "Entombing", "Flaring", "Gentian", "Hallowed", "Illusory", "Impregnable", "Inspired", "Legend's", "Maestro's", "Mirage's", "Polar", "Pope's", "Predator's", "Prophet's", "Ranger's", "Rotund", "Stag's", "Tempered", "Unassailable", "Vaporous", "Virile"];
  const gloveLifeSuffixes = ["of Bameth", "of Buffering", "of Dueling", "of Ephij", "of Exile", "of Ferocity", "of Flexure", "of Furring", "of Haast", "of Magma", "of Renown", "of Tzteosh", "of Windfall", "of the Desperate", "of the Ice", "of the Leviathan", "of the Lightning", "of the Phantom", "of the Savant", "of the Titan", "of the Vampire", "of the Virtuoso", "of the Wind"];
  const gloveLifeCombined = [...gloveLifePrefixes, ...gloveLifeSuffixes, "Aggressor's", "Assailant's", "Bard's", "Bishop's", "Blurred", "Carapaced", "Dauntless", "Duelist's", "Evanescent", "Exarch's", "Flexible", "Girded", "Glaciated", "Haruspex's", "Hero's", "Ibex's", "Incinerating", "Inculcated", "Indomitable", "Interpolated", "Minstrel's", "Nautilus'", "Nightmare's", "Octopus'", "Opalescent", "Phantasm's", "Phased", "Plated", "Pulsing", "Radiating", "Ram's", "Razor-sharp", "Robust", "Sanctified", "Shocking", "Steady", "Sylph's", "Thickened", "Unreal", "Visionary's", "of Combat", "of Dispersal", "of Diversion", "of Excavation", "of Expulsion", "of Fury", "of Mastery", "of Padding", "of the Drought", "of the Goliath", "of the Jaguar", "of the Lamprey", "of the Maelstrom", "of the Polar Bear", "of the Sage", "of the Volcano"];
  const gloveBadMods = ["Agile", "Augur's", "Azure", "Beryl", "Bully's", "Burnished", "Buzzing", "Chilled", "Cobalt", "Flea's", "Focused", "Frosted", "Glinting", "Hale", "Healthy", "Heated", "Humming", "Icy", "Infixed", "Lacquered", "Monk's", "Oyster's", "Poet's", "Polished", "Precise", "Protective", "Reinforced", "Reliable", "Scrapper's", "Shade's", "Shadowy", "Shining", "Smoking", "Smouldering", "Snapping", "of Absorption", "of Conquest", "of Consumption", "of Enveloping", "of Infusion", "of Osmosis", "of Regrowth", "of Rejuvenation", "of Restoration", "of Siphoning", "of Success", "of Triumph", "of Valour", "of Vanquishing", "of Victory", "of the Apt", "of the Bear", "of the Brute", "of the Cloud", "of the Drake", "of the Fox", "of the Lost", "of the Lynx", "of the Mongoose", "of the Narwhal", "of the Newt", "of the Penguin", "of the Prodigy", "of the Pupil", "of the Salamander", "of the Seal", "of the Skilled", "of the Squall", "of the Storm", "of the Student", "of the Talented", "of the Whelpling", "of the Worthy", "of the Wrestler"];

  const bootLifePrefixes = ["Athlete's", "Blazing", "Cherub's", "Durable", "Encased", "Hallowed", "Hellion's", "Illusory", "Impregnable", "Inspired", "Legend's", "Mirage's", "Rotund", "Unassailable", "Vaporous", "Virile"];
  const bootLifeSuffixes = ["of Bameth", "of Buffering", "of Ephij", "of Exile", "of Flexure", "of Furring", "of Haast", "of Magma", "of Tzteosh", "of Windfall", "of the Ice", "of the Jaguar", "of the Leviathan", "of the Lightning", "of the Phantom", "of the Savant", "of the Titan", "of the Virtuoso"];
  const bootLifeCombined = [...bootLifePrefixes, ...bootLifeSuffixes, "Blurred", "Carapaced", "Cheetah's", "Dauntless", "Duelist's", "Evanescent", "Flexible", "Gazelle's", "Girded", "Hero's", "Inculcated", "Indomitable", "Interpolated", "Nightmare's", "Phantasm's", "Phased", "Plated", "Pulsing", "Radiating", "Robust", "Sanctified", "Sylph's", "Thickened", "Unreal", "of Dispersal", "of Diversion", "of Excavation", "of Expulsion", "of Padding", "of the Goliath", "of the Leopard", "of the Maelstrom", "of the Polar Bear", "of the Sage", "of the Volcano"];
  const bootBadMods = ["Agile", "Hale", "Healthy", "Infixed", "Lacquered", "Protective", "Reinforced", "Runner's", "Scrapper's", "Shade's", "Shadowy", "Shining", "of the Apt", "of the Bear", "of the Brute", "of the Cloud", "of the Drake", "of the Flatworm", "of the Fox", "of the Hydra", "of the Lizard", "of the Lost", "of the Lynx", "of the Mongoose", "of the Narwhal", "of the Newt", "of the Penguin", "of the Prodigy", "of the Pupil", "of the Salamander", "of the Seal", "of the Skilled", "of the Squall", "of the Starfish", "of the Storm", "of the Student", "of the Talented", "of the Troll", "of the Whelpling", "of the Worthy", "of the Wrestler"];

  settings.rules.forEach((rule) => {
    if (!rule.enabled) return;

    lines.push(`# ${lang === "ko" ? rule.nameKo : rule.name}`);
    lines.push(`# [RID: ${rule.id}]`);
    lines.push("Show");
    if (staticIdentifiedRules[rule.id]) {
      lines.push(...staticIdentifiedRules[rule.id]);
      lines.push("");
      return;
    }
    lines.push("    Identified True");
    lines.push("    Corrupted False");

    let currentPrefixes, currentSuffixes, currentCombined, currentBadMods, currentClass, currentBaseTypes;

    if (rule.id.includes("body")) {
      currentClass = "Body Armours";
      currentBaseTypes = ["Juggernaut Plate", "Chieftain Cuirass", "Corsair Vest", "Smuggler Coat", "Elementalist Robe", "Mystic Raiment", "Knight Armour", "Ancestral Mail", "Cleric Vestments", "Tideseer Mantle", "Scoundrel Jacket", "Elegant Plate", "Heavy Plate", "Stone Cuirass", "Layered Vest", "Runner Vest", "Lizardscale Coat", "River Raiment", "Adherent's Raiment", "Ceremonial Robe", "Mantled Mail", "Trailblazer Armour", "Golden Mail", "Occultist Mantle", "Plated Vestments", "Heartcarver Mantle", "Itinerant Jacket", "Hatungo Garb", "Hawker's Jacket", "Soldier Cuirass", "Ornate Plate", "Utzaal Cuirass", "Warlord Cuirass", "Swiftstalker Coat", "Slipstrike Vest", "Wyrmscale Coat", "Corsair Coat", "Vile Robe", "Flowing Raiment", "Sacramental Robe", "Feathered Raiment", "Dastard Armour", "Shrouded Mail", "Death Mail", "Thane Mail", "Wolfskin Mantle", "Conjurer Mantle", "Death Mantle", "Seastorm Mantle", "Sleek Jacket", "Rambler Jacket", "Falconer's Jacket", "Austere Garb", "Sacrificial Regalia"];
      currentPrefixes = lifePrefixes;
      currentSuffixes = lifeSuffixes;
      currentCombined = lifeCombined;
      currentBadMods = badMods;
    } else if (rule.id.includes("shield")) {
      currentClass = "Shields";
      currentBaseTypes = ["Crucible Tower Shield", "Ancestor Tower Shield", "Stratified Targe", "Carved Targe", "Wayward Crest Shield", "Seer Crest Shield", "Bulwark Tower Shield", "Noble Tower Shield", "Goldworked Tower Shield", "Polished Targe", "Stone Targe", "Avian Targe", "Dekharan Crest Shield", "Quartered Crest Shield", "Glowering Crest Shield", "Royal Tower Shield", "Fortress Tower Shield", "Vaal Tower Shield", "Mammoth Targe", "Baroque Targe", "Soaring Targe", "Intricate Crest Shield", "Sekheman Crest Shield", "Vaal Crest Shield", "Tawhoan Tower Shield", "Golden Targe", "Blacksteel Crest Shield"];
      currentPrefixes = shieldLifePrefixes;
      currentSuffixes = shieldLifeSuffixes;
      currentCombined = shieldLifeCombined;
      currentBadMods = shieldBadMods;
    } else if (rule.id.includes("helmets")) {
      currentClass = "Helmets";
      currentBaseTypes = ["Commander Greathelm", "Fierce Greathelm", "Corsair Cap", "Leatherbound Hood", "Vermeil Circlet", "Jade Tiara", "Closed Helm", "Spiritbone Crown", "Solid Mask", "Elegant Greathelm", "Noble Greathelm", "Wrapped Cap", "Deerstalker Hood", "Sandsworn Tiara", "Jungle Tiara", "Cabalist Helm", "Gladiatoral Helm", "Hallowed Crown", "Inquisitor Crown", "Pariah Mask", "Avian Mask", "Warmonger Greathelm", "Masked Greathelm", "Paragon Greathelm", "Woven Cap", "Desert Cap", "Trapper Hood", "Skycrown Tiara", "Sorcerous Tiara", "Kamasan Tiara", "Warded Helm", "Cryptic Helm", "Champion Helm", "Druidic Crown", "Saintly Crown", "Divine Crown", "Brigand Mask", "Faridun Mask", "Soaring Mask", "Imperial Greathelm", "Freebooter Cap", "Ancestral Tiara", "Gladiatorial Helm", "Cryptic Crown", "Grinning Mask"];
      currentPrefixes = helmetLifePrefixes;
      currentSuffixes = helmetLifeSuffixes;
      currentCombined = helmetLifeCombined;
      currentBadMods = helmetBadMods;
    } else if (rule.id.includes("gloves")) {
      currentClass = "Gloves";
      currentBaseTypes = ["Detailed Mitts", "Fine Bracers", "Pauascale Gloves", "Plate Gauntlets", "Verisium Cuffs", "Buckled Wraps", "Ancient Mitts", "Feathered Mitts", "Refined Bracers", "Spiked Bracers", "Baroque Gloves", "Gold Gloves", "Zealot Gauntlets", "Ornate Cuffs", "Adorned Wraps", "Knightly Mitts", "Ornate Mitts", "Vaal Mitts", "Stalking Bracers", "Grand Bracers", "Barbed Bracers", "Grim Gloves", "Opulent Gloves", "Vaal Gloves", "Steelmail Gauntlets", "Commander Gauntlets", "Cultist Gauntlets", "Bound Cuffs", "Ancient Cuffs", "Gleaming Cuffs", "War Wraps", "Elegant Wraps", "Vaal Wraps", "Massive Mitts", "Polished Bracers", "Sirenscale Gloves", "Blacksteel Gauntlets", "Adherent Cuffs", "Secured Wraps"];
      currentPrefixes = gloveLifePrefixes;
      currentSuffixes = gloveLifeSuffixes;
      currentCombined = gloveLifeCombined;
      currentBadMods = gloveBadMods;
    } else if (rule.id.includes("boots")) {
      currentClass = "Boots";
      currentBaseTypes = ["Reefsteel Greaves", "Flared Boots", "Flax Sandals", "Covered Sabatons", "Weaver Leggings", "Steelpoint Shoes", "Elegant Greaves", "Carved Greaves", "Studded Boots", "Serpentscale Boots", "Elegant Slippers", "Dunerunner Sandals", "Bastion Sabatons", "Shamanistic Leggings", "Treerunner Shoes", "Bulwark Greaves", "Ornate Greaves", "Vaal Greaves", "Cinched Boots", "Cavalry Boots", "Dragonscale Boots", "Bound Sandals", "Luxurious Slippers", "Sandsworn Sandals", "Veteran Sabatons", "Noble Sabatons", "Fortress Sabatons", "Faithful Leggings", "Apostle Leggings", "Warlock Leggings", "Wanderer Shoes", "Charmed Shoes", "Quickslip Shoes", "Tasalian Greaves", "Drakeskin Boots", "Sekhema Sandals", "Blacksteel Sabatons", "Cryptic Leggings", "Daggerfoot Shoes"];
      currentPrefixes = bootLifePrefixes;
      currentSuffixes = bootLifeSuffixes;
      currentCombined = bootLifeCombined;
      currentBadMods = bootBadMods;
    }

    lines.push(`    Class == "${currentClass}"`);
    lines.push(`    BaseType == ${currentBaseTypes.map(b => `"${b}"`).join(" ")}`);
    lines.push(`    HasExplicitMod >=1 ${currentPrefixes.map(m => `"${m}"`).join(" ")}`);
    lines.push(`    HasExplicitMod >=1 ${currentSuffixes.map(m => `"${m}"`).join(" ")}`);
    
    const count = rule.id.endsWith("_a") ? 4 : 3;
    lines.push(`    HasExplicitMod >=${count} ${currentCombined.map(m => `"${m}"`).join(" ")}`);
    
    if (rule.id.endsWith("_a")) {
        lines.push(`    HasExplicitMod <=1 ${currentBadMods.map(m => `"${m}"`).join(" ")}`);
    } else {
        lines.push(`    HasExplicitMod <=1 ${currentBadMods.map(m => `"${m}"`).join(" ")}`);
    }

    // 스타일 적용
    const styles = rule.styles || {};
    if (styles.fontSize) lines.push(`    SetFontSize ${styles.fontSize}`);
    if (styles.textColor) lines.push(`    SetTextColor ${styles.textColor.r} ${styles.textColor.g} ${styles.textColor.b} ${styles.textColor.a}`);
    if (styles.borderColor) lines.push(`    SetBorderColor ${styles.borderColor.r} ${styles.borderColor.g} ${styles.borderColor.b} ${styles.borderColor.a}`);
    if (styles.backgroundColor) lines.push(`    SetBackgroundColor ${styles.backgroundColor.r} ${styles.backgroundColor.g} ${styles.backgroundColor.b} ${styles.backgroundColor.a}`);
    if (styles.playEffect) lines.push(`    PlayEffect ${styles.playEffect}`);
    if (styles.minimapIcon) lines.push(`    MinimapIcon ${styles.minimapIcon.size} ${styles.minimapIcon.color} ${styles.minimapIcon.shape}`);
    if (styles.playAlertSound && isSndEnabled(styles)) lines.push(`    PlayAlertSound ${styles.playAlertSound.id} ${styles.playAlertSound.volume}`);
    if (styles.customSound && isSndEnabled(styles)) {
      const cs = styles.customSound.startsWith("custom_sound/") ? styles.customSound : `custom_sound/${styles.customSound}`;
      lines.push(`    CustomAlertSound "${cs}"`);
      if (styles.soundVolume) {
        lines.push(`    CustomAlertSoundOptional ${styles.soundVolume}`);
      }
    }

    lines.push("");
  });
}

/**
 * 감정된 에너지 보호막 방어구 규칙 생성
 */
function generateIdentifiedESArmourRules(lines, settings, soundContext, lang = "ko") {
  const { isSndEnabled } = soundContext;
  if (settings.enabled === false) {
    return;
  }

  // 모드 리스트 정의
  const esPrefixes = ["Apparition's", "Banshee's", "Divine", "Duchess'", "Godly", "Grand", "Illusion's", "Illusory", "Impenetrable", "Incandescent", "Incorporeal", "Inspired", "Interpermeated", "Princess'", "Queen's", "Resplendent", "Saintly", "Stalker's", "Unassailable", "Unfaltering", "Victor's"];
  const esSuffixes = ["of Anticipation", "of Bameth", "of Ephij", "of Haast", "of Magma", "of Thermokryptance", "of Tzteosh", "of Warping", "of the Ice", "of the Jaguar", "of the Leviathan", "of the Lightning", "of the Phantom", "of the Savant", "of the Titan", "of the Virtuoso"];
  const esCombined = [...esPrefixes, ...esSuffixes, "Archon's", "Consecrated", "Countess'", "Dazzling", "Eidolon's", "High Priest's", "Indomitable", "Interpolated", "Paladin's", "Phantom's", "Rogue's", "Scintillating", "Unreal", "of Diversion", "of Excitement", "of Exile", "of Expulsion", "of Flexure", "of Furring", "of Motivation", "of Padding", "of the Goliath", "of the Leopard", "of the Maelstrom", "of the Polar Bear", "of the Sage", "of the Volcano"];
  const esBadMods = ["Abbot's", "Anointed", "Athlete's", "Augur's", "Auspex's", "Barbed", "Bard's", "Baronness'", "Bishop's", "Blessed", "Deacon's", "Druid's", "Edged", "Ethereal", "Exarch's", "Fecund", "Glimmering", "Glittering", "Glowing", "Hale", "Haruspex's", "Healthy", "Infixed", "Ingrained", "Instilled", "Jagged", "Lady's", "Minstrel's", "Monk's", "Musician's", "Nymph's", "Poet's", "Pointed", "Prior's", "Protective", "Pursuer's", "Resolute", "Robust", "Rotund", "Sanctified", "Sanguine", "Shadowy", "Shining", "Spiked", "Spiny", "Stalwart", "Stout", "Strong-Willed", "Sylph's", "Thorny", "Troubadour's", "Unworldly", "Vigorous", "Virile", "Visionary's", "Will-o-wisp's", "of Convalescence", "of Covering", "of Deflecting", "of Impatience", "of Recuperation", "of Resurgence", "of the Apt", "of the Bear", "of the Brute", "of the Cloud", "of the Drake", "of the Flatworm", "of the Fox", "of the Hydra", "of the Lizard", "of the Lost", "of the Lynx", "of the Mongoose", "of the Narwhal", "of the Newt", "of the Penguin", "of the Prodigy", "of the Pupil", "of the Salamander", "of the Seal", "of the Skilled", "of the Squall", "of the Starfish", "of the Storm", "of the Student", "of the Talented", "of the Troll", "of the Whelpling", "of the Worthy", "of the Wrestler"];

  const shieldESPrefixes = ["Adamant", "Apparition's", "Cryomancer's", "Crystalline", "Electromancer's", "Glyphic", "Illusion's", "Illusory", "Impenetrable", "Incandescent", "Incorporeal", "Inspired", "Interpermeated", "Ionising", "Malevolent", "Oppressor's", "Pyromancer's", "Runic", "Saintly", "Scintillating", "Torturer's", "Twisted", "Unassailable", "Unfaltering", "Victor's", "Volcanic"];
  const shieldESSuffixes = ["of Bameth", "of Ephij", "of Ferocity", "of Haast", "of Harmony", "of Magma", "of Prestidigitation", "of Ruin", "of Suffusion", "of Thermokryptance", "of Tzteosh", "of Warping", "of the Enchanter", "of the Everlasting", "of the Ice", "of the Jaguar", "of the Leviathan", "of the Lightning", "of the Lightning Rod", "of the Mammoth", "of the Phantom", "of the Savant", "of the Solar Storm", "of the Span", "of the Titan", "of the Virtuoso"];
  const shieldESCombined = [...shieldESPrefixes, ...shieldESSuffixes, "Agonising", "Arctic", "Beatified", "Consecrated", "Dazzling", "Eidolon's", "Incanter's", "Indomitable", "Interpolated", "Magmatic", "Smiting", "Spirit's", "Unreal", "Unrelenting", "Vile", "of Ardour", "of Buffering", "of Calamity", "of Concord", "of Diversion", "of Exile", "of Expulsion", "of Flexure", "of Furring", "of Fury", "of Legerdemain", "of Padding", "of Shockproofing", "of Sortilege", "of Variegation", "of the Deathless", "of the Goliath", "of the Leopard", "of the Maelstrom", "of the Mage", "of the Molten Core", "of the Polar Bear", "of the Rainbow", "of the Sage", "of the Tundra", "of the Volcano"];
  const shieldESBadMods = ["Adept's", "Alpine", "Apprentice's", "Athlete's", "Barbed", "Biting", "Bitter", "Blessed", "Blistering", "Bolting", "Charged", "Clouded", "Edged", "Ethereal", "Glimmering", "Glittering", "Hale", "Healthy", "Hissing", "Impure", "Infixed", "Ingrained", "Instilled", "Jagged", "Pointed", "Protective", "Punishing", "Resolute", "Robust", "Rotund", "Sanguine", "Scholar's", "Searing", "Shadowy", "Shining", "Sizzling", "Spiked", "Spiny", "Stalwart", "Stout", "Strong-Willed", "Tainted", "Thorny", "Unforgiving", "Unworldly", "Vengeful", "Virile", "Will-o-wisp's", "of Covering", "of Deflecting", "of Enlivening", "of Talent", "of the Apt", "of the Bear", "of the Brute", "of the Cloud", "of the Crystal", "of the Drake", "of the Fox", "of the Lost", "of the Lynx", "of the Mongoose", "of the Narwhal", "of the Penguin", "of the Prodigy", "of the Pupil", "of the Salamander", "of the Seal", "of the Skilled", "of the Squall", "of the Storm", "of the Student", "of the Talented", "of the Whelpling", "of the Worthy", "of the Wrestler"];

  const helmetESPrefixes = ["Amazon's", "Angel's", "Beatified", "Blazing", "Dazzling", "Dragon's", "Falcon's", "Illusory", "Inspired", "Ranger's", "Spirit's", "Unassailable", "Whale's"];
  const helmetESSuffixes = ["of Bameth", "of Buffering", "of Ephij", "of Exile", "of Flexure", "of Furring", "of Haast", "of Magma", "of Tzteosh", "of Windfall", "of the Genius", "of the Ice", "of the Jaguar", "of the Leviathan", "of the Lightning", "of the Phantom", "of the Titan", "of the Virtuoso"];
  const helmetESCombined = [...helmetESPrefixes, ...helmetESSuffixes, "Celestial", "Cherub's", "Dauntless", "Dolphin's", "Eagle's", "Evanescent", "Hallowed", "Hawk's", "Heavenly", "Inculcated", "Indomitable", "Interpolated", "Orca's", "Pirate's", "Pulsing", "Steady", "Unreal", "of Dispersal", "of Diversion", "of Excavation", "of Expulsion", "of Padding", "of the Goliath", "of the Leopard", "of the Maelstrom", "of the Polar Bear", "of the Savant", "of the Volcano"];
  const helmetESBadMods = ["Abbot's", "Augur's", "Auspex's", "Bard's", "Bishop's", "Coelacanth's", "Druid's", "Exarch's", "Focused", "Glimmering", "Glittering", "Hale", "Haruspex's", "Healthy", "Imbued", "Infixed", "Minstrel's", "Monk's", "Musician's", "Poet's", "Precise", "Prior's", "Protective", "Reliable", "Robust", "Rotund", "Sanguine", "Shadowy", "Shining", "Stalwart", "Stout", "Troubadour's", "Virile", "Visionary's", "Vulture's", "of Light", "of Radiance", "of Shining", "of the Apt", "of the Bear", "of the Brute", "of the Cloud", "of the Drake", "of the Flatworm", "of the Fox", "of the Hydra", "of the Lizard", "of the Lost", "of the Lynx", "of the Mongoose", "of the Narwhal", "of the Newt", "of the Penguin", "of the Prodigy", "of the Pupil", "of the Salamander", "of the Seal", "of the Skilled", "of the Squall", "of the Starfish", "of the Storm", "of the Student", "of the Talented", "of the Troll", "of the Whelpling", "of the Worthy", "of the Wrestler"];

  const gloveESPrefixes = ["Amazon's", "Blasting", "Blazing", "Chalybeous", "Cherub's", "Cremating", "Discharging", "Electrocuting", "Entombing", "Flaring", "Gentian", "Hallowed", "Illusory", "Inspired", "Polar", "Ranger's", "Tempered", "Unassailable"];
  const gloveESSuffixes = ["of Bameth", "of Buffering", "of Dueling", "of Ephij", "of Flexure", "of Furring", "of Haast", "of Magma", "of Renown", "of Tzteosh", "of Windfall", "of the Desperate", "of the Ice", "of the Leviathan", "of the Lightning", "of the Phantom", "of the Savant", "of the Titan", "of the Virtuoso", "of the Wind"];
  const gloveESCombined = [...gloveESPrefixes, ...gloveESSuffixes, "Dauntless", "Evanescent", "Glaciated", "Incinerating", "Inculcated", "Indomitable", "Interpolated", "Opalescent", "Pulsing", "Radiating", "Razor-sharp", "Sanctified", "Shocking", "Steady", "Sylph's", "Unreal", "of Combat", "of Dispersal", "of Diversion", "of Excavation", "of Exile", "of Expulsion", "of Mastery", "of Padding", "of the Drought", "of the Goliath", "of the Jaguar", "of the Maelstrom", "of the Polar Bear", "of the Sage", "of the Volcano"];
  const gloveESBadMods = ["Abbot's", "Augur's", "Auspex's", "Azure", "Bard's", "Beryl", "Bishop's", "Burnished", "Buzzing", "Chilled", "Cobalt", "Druid's", "Exarch's", "Focused", "Frosted", "Glinting", "Hale", "Haruspex's", "Healthy", "Heated", "Humming", "Icy", "Infixed", "Minstrel's", "Monk's", "Musician's", "Poet's", "Polished", "Precise", "Prior's", "Protective", "Reliable", "Robust", "Rotund", "Sanguine", "Shadowy", "Shining", "Smoking", "Smouldering", "Snapping", "Stalwart", "Stout", "Troubadour's", "Visionary's", "of Absorption", "of Conquest", "of Consumption", "of Enveloping", "of Infusion", "of Osmosis", "of Regrowth", "of Rejuvenation", "of Restoration", "of Siphoning", "of Success", "of Triumph", "of Valour", "of Vanquishing", "of Victory", "of the Apt", "of the Bear", "of the Brute", "of the Cloud", "of the Drake", "of the Fox", "of the Lamprey", "of the Locust", "of the Lost", "of the Lynx", "of the Mongoose", "of the Narwhal", "of the Parasite", "of the Penguin", "of the Prodigy", "of the Pupil", "of the Remora", "of the Salamander", "of the Seal", "of the Skilled", "of the Squall", "of the Storm", "of the Student", "of the Talented", "of the Whelpling", "of the Worthy", "of the Wrestler"];

  const bootESPrefixes = ["Blazing", "Cherub's", "Hallowed", "Hellion's", "Illusory", "Inspired", "Unassailable"];
  const bootESSuffixes = ["of Bameth", "of Buffering", "of Ephij", "of Flexure", "of Furring", "of Haast", "of Magma", "of Tzteosh", "of Windfall", "of the Ice", "of the Jaguar", "of the Leviathan", "of the Lightning", "of the Phantom", "of the Savant", "of the Titan", "of the Virtuoso"];
  const bootESCombined = [...bootESPrefixes, ...bootESSuffixes, "Cheetah's", "Dauntless", "Evanescent", "Gazelle's", "Inculcated", "Indomitable", "Interpolated", "Pulsing", "Radiating", "Sanctified", "Sylph's", "Unreal", "of Dispersal", "of Diversion", "of Excavation", "of Exile", "of Expulsion", "of Padding", "of the Goliath", "of the Leopard", "of the Maelstrom", "of the Polar Bear", "of the Sage", "of the Volcano"];
  const bootESBadMods = ["Hale", "Healthy", "Infixed", "Protective", "Robust", "Rotund", "Runner's", "Sanguine", "Shadowy", "Shining", "Stalwart", "Stout", "of the Apt", "of the Bear", "of the Brute", "of the Cloud", "of the Drake", "of the Flatworm", "of the Fox", "of the Hydra", "of the Lizard", "of the Lost", "of the Lynx", "of the Mongoose", "of the Narwhal", "of the Newt", "of the Penguin", "of the Prodigy", "of the Pupil", "of the Salamander", "of the Seal", "of the Skilled", "of the Squall", "of the Starfish", "of the Storm", "of the Student", "of the Talented", "of the Troll", "of the Whelpling", "of the Worthy", "of the Wrestler"];

  settings.rules.forEach((rule) => {
    if (!rule.enabled) return;

    lines.push(`# ${lang === "ko" ? rule.nameKo : rule.name}`);
    lines.push(`# [RID: ${rule.id}]`);
    lines.push("Show");
    if (staticIdentifiedRules[rule.id]) {
      lines.push(...staticIdentifiedRules[rule.id]);
      lines.push("");
      return;
    }
    lines.push("    Identified True");
    lines.push("    Corrupted False");

    let currentPrefixes, currentSuffixes, currentCombined, currentBadMods, currentClass, currentBaseTypes;

    if (rule.id.includes("body")) {
      currentClass = "Body Armours";
      currentBaseTypes = ["Elementalist Robe", "Mystic Raiment", "Cleric Vestments", "Tideseer Mantle", "Scoundrel Jacket", "River Raiment", "Adherent's Raiment", "Ceremonial Robe", "Occultist Mantle", "Plated Vestments", "Heartcarver Mantle", "Itinerant Jacket", "Hatungo Garb", "Hawker's Jacket", "Vile Robe", "Flowing Raiment", "Sacramental Robe", "Feathered Raiment", "Wolfskin Mantle", "Conjurer Mantle", "Death Mantle", "Seastorm Mantle", "Sleek Jacket", "Rambler Jacket", "Falconer's Jacket", "Austere Garb", "Sacrificial Regalia"];
      currentPrefixes = esPrefixes;
      currentSuffixes = esSuffixes;
      currentCombined = esCombined;
      currentBadMods = esBadMods;
    } else if (rule.id.includes("shield")) {
      currentClass = "Shields";
      currentBaseTypes = ["Wayward Crest Shield", "Seer Crest Shield", "Dekharan Crest Shield", "Quartered Crest Shield", "Glowering Crest Shield", "Intricate Crest Shield", "Sekheman Crest Shield", "Vaal Crest Shield", "Blacksteel Crest Shield"];
      currentPrefixes = shieldESPrefixes;
      currentSuffixes = shieldESSuffixes;
      currentCombined = shieldESCombined;
      currentBadMods = shieldESBadMods;
    } else if (rule.id.includes("helmets")) {
      currentClass = "Helmets";
      currentBaseTypes = ["Vermeil Circlet", "Jade Tiara", "Spiritbone Crown", "Solid Mask", "Sandsworn Tiara", "Jungle Tiara", "Hallowed Crown", "Inquisitor Crown", "Pariah Mask", "Avian Mask", "Skycrown Tiara", "Sorcerous Tiara", "Kamasan Tiara", "Druidic Crown", "Saintly Crown", "Divine Crown", "Brigand Mask", "Faridun Mask", "Soaring Mask", "Ancestral Tiara", "Cryptic Crown", "Grinning Mask"];
      currentPrefixes = helmetESPrefixes;
      currentSuffixes = helmetESSuffixes;
      currentCombined = helmetESCombined;
      currentBadMods = helmetESBadMods;
    } else if (rule.id.includes("gloves")) {
      currentClass = "Gloves";
      currentBaseTypes = ["Pauascale Gloves", "Verisium Cuffs", "Buckled Wraps", "Baroque Gloves", "Gold Gloves", "Ornate Cuffs", "Adorned Wraps", "Grim Gloves", "Opulent Gloves", "Vaal Gloves", "Bound Cuffs", "Ancient Cuffs", "Gleaming Cuffs", "War Wraps", "Elegant Wraps", "Vaal Wraps", "Sirenscale Gloves", "Adherent Cuffs", "Secured Wraps"];
      currentPrefixes = gloveESPrefixes;
      currentSuffixes = gloveESSuffixes;
      currentCombined = gloveESCombined;
      currentBadMods = gloveESBadMods;
    } else if (rule.id.includes("boots")) {
      currentClass = "Boots";
      currentBaseTypes = ["Flax Sandals", "Weaver Leggings", "Steelpoint Shoes", "Elegant Slippers", "Dunerunner Sandals", "Shamanistic Leggings", "Treerunner Shoes", "Bound Sandals", "Luxurious Slippers", "Sandsworn Sandals", "Faithful Leggings", "Apostle Leggings", "Warlock Leggings", "Wanderer Shoes", "Charmed Shoes", "Quickslip Shoes", "Sekhema Sandals", "Cryptic Leggings", "Daggerfoot Shoes"];
      currentPrefixes = bootESPrefixes;
      currentSuffixes = bootESSuffixes;
      currentCombined = bootESCombined;
      currentBadMods = bootESBadMods;
    }

    lines.push(`    Class == "${currentClass}"`);
    lines.push(`    BaseType == ${currentBaseTypes.map(b => `"${b}"`).join(" ")}`);
    lines.push(`    HasExplicitMod >=1 ${currentPrefixes.map(m => `"${m}"`).join(" ")}`);
    lines.push(`    HasExplicitMod >=1 ${currentSuffixes.map(m => `"${m}"`).join(" ")}`);
    
    const count = rule.id.endsWith("_a") ? 4 : 3;
    lines.push(`    HasExplicitMod >=${count} ${currentCombined.map(m => `"${m}"`).join(" ")}`);
    
    if (rule.id.endsWith("_a")) {
        lines.push(`    HasExplicitMod <=1 ${currentBadMods.map(m => `"${m}"`).join(" ")}`);
    } else {
        lines.push(`    HasExplicitMod <=1 ${currentBadMods.map(m => `"${m}"`).join(" ")}`);
    }

    // 스타일 적용
    const styles = rule.styles || {};
    if (styles.fontSize) lines.push(`    SetFontSize ${styles.fontSize}`);
    if (styles.textColor) lines.push(`    SetTextColor ${styles.textColor.r} ${styles.textColor.g} ${styles.textColor.b} ${styles.textColor.a}`);
    if (styles.borderColor) lines.push(`    SetBorderColor ${styles.borderColor.r} ${styles.borderColor.g} ${styles.borderColor.b} ${styles.borderColor.a}`);
    if (styles.backgroundColor) lines.push(`    SetBackgroundColor ${styles.backgroundColor.r} ${styles.backgroundColor.g} ${styles.backgroundColor.b} ${styles.backgroundColor.a}`);
    if (styles.playEffect) lines.push(`    PlayEffect ${styles.playEffect}`);
    if (styles.minimapIcon) lines.push(`    MinimapIcon ${styles.minimapIcon.size} ${styles.minimapIcon.color} ${styles.minimapIcon.shape}`);
    if (styles.playAlertSound && isSndEnabled(styles)) lines.push(`    PlayAlertSound ${styles.playAlertSound.id} ${styles.playAlertSound.volume}`);
    if (styles.customSound && isSndEnabled(styles)) {
      const cs = styles.customSound.startsWith("custom_sound/") ? styles.customSound : `custom_sound/${styles.customSound}`;
      lines.push(`    CustomAlertSound "${cs}"`);
      if (styles.soundVolume) {
        lines.push(`    CustomAlertSoundOptional ${styles.soundVolume}`);
      }
    }

    lines.push("");
  });
}

/**
 * 호신부 규칙 생성
 */
function generateCharmsRules(lines, charmsSettings, soundContext, lang = "ko") {
  if (charmsSettings.enabled === false) {
    return;
  }

  charmsSettings.rules.forEach((rule) => {
    if (!rule.enabled) {
      return;
    }

    // 제목 주석
    const title = lang === "ko" ? rule.nameKo || rule.name : rule.name;
    lines.push(`# ${title}`);

    // 규칙 ID 주석
    lines.push(`# [RID: ${rule.id}]`);

    // Show/Hide
    lines.push(rule.type === "hide" ? "Hide" : "Show");

    // ItemLevel 조건
    if (rule.conditions?.itemLevel) {
      const { operator, value } = rule.conditions.itemLevel;
      lines.push(`  ItemLevel ${operator} ${value}`);
    }

    // Mirrored 조건
    if (rule.conditions?.mirrored !== undefined) {
      const value = rule.conditions.mirrored.value;
      lines.push(`  Mirrored ${value ? "True" : "False"}`);
    }

    // Corrupted 조건
    if (rule.conditions?.corrupted !== undefined) {
      const value = rule.conditions.corrupted.value;
      lines.push(`  Corrupted ${value ? "True" : "False"}`);
    }

    // AreaLevel 조건 (단일)
    if (rule.conditions?.areaLevel) {
      const { operator, value } = rule.conditions.areaLevel;
      lines.push(`  AreaLevel ${operator} ${value}`);
    }

    // AreaLevel Min/Max 조건 (범위)
    if (rule.conditions?.areaLevelMin) {
      const { operator, value } = rule.conditions.areaLevelMin;
      lines.push(`  AreaLevel ${operator} ${value}`);
    }
    if (rule.conditions?.areaLevelMax) {
      const { operator, value } = rule.conditions.areaLevelMax;
      lines.push(`  AreaLevel ${operator} ${value}`);
    }

    // Class 조건
    if (rule.conditions?.class) {
      const classValue = rule.conditions.class.value;
      if (Array.isArray(classValue)) {
        const classes = classValue.map(c => `"${c}"`).join(" ");
        lines.push(`  Class == ${classes}`);
      } else {
        lines.push(`  Class == "${classValue}"`);
      }
    }

    // BaseType 조건
    if (rule.conditions?.baseType) {
      const baseValue = rule.conditions.baseType.value;
      if (Array.isArray(baseValue)) {
        const bases = baseValue.map(b => `"${b}"`).join(" ");
        lines.push(`  BaseType == ${bases}`);
      } else {
        lines.push(`  BaseType == "${baseValue}"`);
      }
    }

    // Rarity 조건
    if (rule.conditions?.rarity) {
      const { operator, value } = rule.conditions.rarity;
      if (Array.isArray(value)) {
        lines.push(`  Rarity ${value.join(" ")}`);
      } else if (operator === ">=") {
        lines.push(`  Rarity ${operator} ${value}`);
      } else {
        lines.push(`  Rarity ${value}`);
      }
    }

    // 스타일 적용
    const styles = rule.styles || {};
    
    if (styles.fontSize) {
      lines.push(`  SetFontSize ${styles.fontSize}`);
    }
    if (styles.textColor) {
      const { r, g, b, a } = styles.textColor;
      lines.push(`  SetTextColor ${r} ${g} ${b} ${a}`);
    }
    if (styles.borderColor) {
      const { r, g, b, a } = styles.borderColor;
      lines.push(`  SetBorderColor ${r} ${g} ${b} ${a}`);
    }
    if (styles.backgroundColor) {
      const { r, g, b, a } = styles.backgroundColor;
      lines.push(`  SetBackgroundColor ${r} ${g} ${b} ${a}`);
    }
    if (styles.playEffect) {
      lines.push(`  PlayEffect ${styles.playEffect}`);
    }
    if (styles.minimapIcon) {
      const { size, color, shape } = styles.minimapIcon;
      if (size !== null && size !== undefined) {
        lines.push(`  MinimapIcon ${size} ${color || "Orange"} ${shape || "Kite"}`);
      }
    }
    if (styles.playAlertSound && isSndEnabled(styles)) {
      const { id, volume } = styles.playAlertSound;
      lines.push(`  PlayAlertSound ${id} ${volume}`);
    }
    if (styles.customSound && isSndEnabled(styles)) {
      const cs = styles.customSound.startsWith("custom_sound/") ? styles.customSound : `custom_sound/${styles.customSound}`;
      lines.push(`  CustomAlertSound "${cs}"`);
      if (styles.soundVolume) {
        lines.push(`  CustomAlertSoundOptional ${styles.soundVolume}`);
      }
    }

    lines.push("");
  });
}

/**
 * 기타 (주문 감정서 등) 규칙 생성
 */
function generateOthersRules(lines, othersSettings, soundContext, lang = "ko") {
  const { isSndEnabled } = soundContext;
  if (othersSettings.enabled === false) {
    return;
  }

  othersSettings.rules.forEach((rule) => {
    if (!rule.enabled) {
      return;
    }

    // 제목 주석
    const title = lang === "ko" ? rule.nameKo || rule.name : rule.name;
    lines.push(`# ${title}`);

    // RID 주석
    lines.push(`# [RID: ${rule.id}]`);

    // Show/Hide
    lines.push(rule.type === "hide" ? "Hide" : "Show");

    // Class 조건
    if (rule.conditions?.class) {
      const classValue = rule.conditions.class.value;
      if (Array.isArray(classValue)) {
        const classes = classValue.map((c) => `"${c}"`).join(" ");
        lines.push(`  Class == ${classes}`);
      } else {
        lines.push(`  Class == "${classValue}"`);
      }
    }

    // BaseType 조건 (단수)
    if (rule.conditions?.baseType) {
      const baseTypeValue = rule.conditions.baseType.value;
      if (Array.isArray(baseTypeValue)) {
        const baseTypes = baseTypeValue.map((b) => `"${b}"`).join(" ");
        lines.push(`  BaseType == ${baseTypes}`);
      } else {
        lines.push(`  BaseType == "${baseTypeValue}"`);
      }
    }

    // BaseType 조건 (복수 - baseTypes 배열)
    if (rule.conditions?.baseTypes && Array.isArray(rule.conditions.baseTypes)) {
      const baseTypes = rule.conditions.baseTypes.map((b) => `"${b}"`).join(" ");
      lines.push(`  BaseType == ${baseTypes}`);
    }

    // AreaLevel 조건
    if (rule.conditions?.areaLevel) {
      const { operator, value } = rule.conditions.areaLevel;
      lines.push(`  AreaLevel ${operator} ${value}`);
    }

    // Rarity 조건
    if (rule.conditions?.rarity) {
      const { operator, value } = rule.conditions.rarity;
      lines.push(`  Rarity ${operator || "=="} ${value}`);
    }

    // ItemLevel 조건 (전직 아이템용)
    if (rule.itemLevelEnabled && rule.itemLevelValue) {
      lines.push(`  ItemLevel ${rule.itemLevelOperator || ">="} ${rule.itemLevelValue}`);
    }

    // Corrupted 조건
    if (rule.conditions?.corrupted !== undefined) {
      const corruptedValue = rule.conditions.corrupted.value;
      lines.push(`  Corrupted ${corruptedValue ? "True" : "False"}`);
    }

    // BaseTypes 배열 조건 (찬스 아이템 등)
    if (rule.conditions?.baseTypes && Array.isArray(rule.conditions.baseTypes) && rule.conditions.baseTypes.length > 0) {
      // 한글 아이템 이름을 영어로 변환하는 매핑
      const koToEnMapping = {
        "무궁한 주얼": "Timeless Jewel",
        "은 호신부": "Silver Charm",
        "무거운 허리띠": "Heavy Belt",
        "가죽 허리띠": "Leather Belt",
        "천 허리띠": "Cloth Belt",
        "황금 주얼": "Gold Jewel",
        "영롱한 주얼": "Prismatic Jewel",
        "심연 주얼": "Abyss Jewel",
        "군단 주얼": "Legion Jewel",
        "금 호신부": "Gold Charm",
        "상아 호신부": "Ivory Charm",
        "뼈 호신부": "Bone Charm"
      };
      
      // 한글 이름을 영어로 변환 (매핑에 없으면 원래 이름 사용)
      const englishBaseTypes = rule.conditions.baseTypes.map(item => 
        koToEnMapping[item] || item
      );
      
      const baseTypesStr = englishBaseTypes.map((b) => `"${b}"`).join(" ");
      lines.push(`  BaseType == ${baseTypesStr}`);
    }

    // 스타일 적용
    if (rule.type === "show" && rule.styles) {
      const styles = rule.styles;

      if (styles.fontSize) {
        lines.push(`  SetFontSize ${styles.fontSize}`);
      }

      if (styles.textColor) {
        const { r, g, b, a } = styles.textColor;
        lines.push(`  SetTextColor ${r} ${g} ${b} ${a}`);
      }

      if (styles.borderColor) {
        const { r, g, b, a } = styles.borderColor;
        lines.push(`  SetBorderColor ${r} ${g} ${b} ${a}`);
      }

      if (styles.backgroundColor) {
        const { r, g, b, a } = styles.backgroundColor;
        lines.push(`  SetBackgroundColor ${r} ${g} ${b} ${a}`);
      }

      if (styles.playEffect) {
        lines.push(`  PlayEffect ${styles.playEffect}`);
      }

      if (styles.minimapIcon) {
        const { size, color, shape } = styles.minimapIcon;
        if (size !== null || color !== null || shape !== null) {
          lines.push(`  MinimapIcon ${size || 0} ${color || "White"} ${shape || "Circle"}`);
        }
      }

      if (styles.customSound && isSndEnabled(styles)) {
        if (/^\d+\s+\d+$/.test(styles.customSound)) {
          const [id, vol] = styles.customSound.split(" ");
          lines.push(`  PlayAlertSound ${id} ${vol}`);
        } else {
          const cs = styles.customSound.startsWith("custom_sound/") ? styles.customSound : `custom_sound/${styles.customSound}`;
          lines.push(`  CustomAlertSound "${cs}" 300`);
        }
      }
    }

    lines.push("");
  });
}

/**
 * 경로석 규칙 생성
 */
function generateWaystonesRules(lines, waystonesSettings, soundContext, lang = "ko") {
  const { isSndEnabled } = soundContext;
  if (!waystonesSettings || !waystonesSettings.enabled) {
    return;
  }

  const rules = waystonesSettings.rules || [];

  rules.forEach((rule) => {
    if (!rule.enabled) return;

    // 규칙 이름 주석
    const ruleName = lang === "ko" ? rule.nameKo || rule.name : rule.name;
    lines.push(`# ${ruleName}`);

    // RID 주석
    lines.push(`# [RID: ${rule.id}]`);

    // Show/Hide
    lines.push(rule.type === "hide" ? "Hide" : "Show");

    // Class 조건
    if (rule.conditions?.class) {
      const { operator, value } = rule.conditions.class;
      if (Array.isArray(value)) {
        const classes = value.map((c) => `"${c}"`).join(" ");
        lines.push(`  Class ${operator || "=="} ${classes}`);
      } else {
        lines.push(`  Class ${operator || "=="} "${value}"`);
      }
    }

    // WaystoneTier 조건
    if (rule.conditions?.waystoneTier) {
      const { operator, value } = rule.conditions.waystoneTier;
      lines.push(`  WaystoneTier ${operator} ${value}`);
    }

    // Corrupted 조건
    if (rule.conditions?.corrupted) {
      const { operator, value } = rule.conditions.corrupted;
      lines.push(`  Corrupted ${operator || "=="} ${value}`);
    }

    // 스타일 적용
    if (rule.styles) {
      const styles = rule.styles;

      if (styles.fontSize) {
        lines.push(`  SetFontSize ${styles.fontSize}`);
      }

      if (styles.textColor) {
        const { r, g, b, a } = styles.textColor;
        lines.push(`  SetTextColor ${r} ${g} ${b} ${a}`);
      }

      if (styles.borderColor) {
        const { r, g, b, a } = styles.borderColor;
        lines.push(`  SetBorderColor ${r} ${g} ${b} ${a}`);
      }

      if (styles.backgroundColor) {
        const { r, g, b, a } = styles.backgroundColor;
        lines.push(`  SetBackgroundColor ${r} ${g} ${b} ${a}`);
      }

      if (styles.playEffect) {
        lines.push(`  PlayEffect ${styles.playEffect}`);
      }

      if (styles.minimapIcon) {
        const { size, color, shape } = styles.minimapIcon;
        lines.push(`  MinimapIcon ${size} ${color} ${shape}`);
      }

      if (styles.customSound && isSndEnabled(styles)) {
        if (/^\d+\s+\d+$/.test(styles.customSound)) {
          const [id, vol] = styles.customSound.split(" ");
          lines.push(`  PlayAlertSound ${id} ${vol}`);
        } else {
          const cs = styles.customSound.startsWith("custom_sound/") ? styles.customSound : `custom_sound/${styles.customSound}`;
          lines.push(`  CustomAlertSound "${cs}" 300`);
        }
      }
    }

    lines.push("");
  });
}

/**
 * 탐험 규칙 생성
 */
function generateExpeditionRules(lines, expeditionSettings, soundContext, lang = "ko") {
  const { isSndEnabled } = soundContext;
  if (!expeditionSettings || !expeditionSettings.enabled) {
    return;
  }

  const rules = expeditionSettings.rules || [];

  rules.forEach((rule) => {
    if (!rule.enabled) return;

    // 규칙 이름 주석
    const ruleName = lang === "ko" ? rule.nameKo || rule.name : rule.name;
    lines.push(`# ${ruleName}`);

    // RID 주석
    lines.push(`# [RID: ${rule.id}]`);

    // Show/Hide
    lines.push(rule.type === "hide" ? "Hide" : "Show");

    // Class 조건
    if (rule.conditions?.class) {
      const { operator, value } = rule.conditions.class;
      if (Array.isArray(value)) {
        const classes = value.map((c) => `"${c}"`).join(" ");
        lines.push(`  Class ${operator || "=="} ${classes}`);
      } else {
        lines.push(`  Class ${operator || "=="} "${value}"`);
      }
    }

    // BaseType 조건
    if (rule.conditions?.baseType) {
      const { operator, value } = rule.conditions.baseType;
      if (Array.isArray(value)) {
        const baseTypes = value.map((b) => `"${b}"`).join(" ");
        lines.push(`  BaseType ${operator || "=="} ${baseTypes}`);
      } else {
        lines.push(`  BaseType ${operator || "=="} "${value}"`);
      }
    }

    // ItemLevel 조건
    if (rule.conditions?.itemLevel) {
      const { operator, value } = rule.conditions.itemLevel;
      lines.push(`  ItemLevel ${operator} ${value}`);
    }

    // AreaLevel 조건
    if (rule.conditions?.areaLevel) {
      const { operator, value } = rule.conditions.areaLevel;
      lines.push(`  AreaLevel ${operator} ${value}`);
    }

    // Rarity 조건
    if (rule.conditions?.rarity) {
      const { operator, value } = rule.conditions.rarity;
      if (Array.isArray(value)) {
        lines.push(`  Rarity ${value.join(" ")}`);
      } else if (operator) {
        lines.push(`  Rarity ${operator} ${value}`);
      } else {
        lines.push(`  Rarity ${value}`);
      }
    }

    // 스타일 적용
    if (rule.styles) {
      const styles = rule.styles;

      if (styles.fontSize) {
        lines.push(`  SetFontSize ${styles.fontSize}`);
      }

      if (styles.textColor) {
        const { r, g, b, a } = styles.textColor;
        lines.push(`  SetTextColor ${r} ${g} ${b} ${a}`);
      }

      if (styles.borderColor) {
        const { r, g, b, a } = styles.borderColor;
        lines.push(`  SetBorderColor ${r} ${g} ${b} ${a}`);
      }

      if (styles.backgroundColor) {
        const { r, g, b, a } = styles.backgroundColor;
        lines.push(`  SetBackgroundColor ${r} ${g} ${b} ${a}`);
      }

      if (styles.playEffect) {
        lines.push(`  PlayEffect ${styles.playEffect}`);
      }

      if (styles.minimapIcon) {
        const { size, color, shape } = styles.minimapIcon;
        lines.push(`  MinimapIcon ${size} ${color} ${shape}`);
      }

      if (styles.customSound && isSndEnabled(styles)) {
        if (/^\d+\s+\d+$/.test(styles.customSound)) {
          const [id, vol] = styles.customSound.split(" ");
          lines.push(`  PlayAlertSound ${id} ${vol}`);
        } else {
          const cs = styles.customSound.startsWith("custom_sound/") ? styles.customSound : `custom_sound/${styles.customSound}`;
          lines.push(`  CustomAlertSound "${cs}" 300`);
        }
      }
    }

    lines.push("");
  });
}

/**
 * 유니크 아이템 규칙 생성
 */
function generateUniquesRules(
  lines,
  preset,
  settings, // Renamed from options to settings for clarity
  soundContext,
  excludedItemsList = [], // Added excludedItemsList
  uniqueTierStyles = {}, // Added uniqueTierStyles
  lang = "ko"
) {
  if (!settings || !settings.enabled) return;

  const { isPS5, isSOnly, isSilent, soundSettings, isSndEnabled } = soundContext;
  
  // 1. S, A, B, C 티어 유니크 생성
  // minTier 설정 확인
  const minTier = settings.minTier || "D";
  const tierOrder = { S: 1, A: 2, B: 3, C: 4, D: 5 };
  const minTierVal = tierOrder[minTier] || 5;

  const tiers = ["S", "A", "B", "C", "D"];

  tiers.forEach(tier => {
    // 티어 필터링
    if (tierOrder[tier] > minTierVal) return;

    const items = uniquesTiers[tier];
    if (!items || items.length === 0) return;

    // 규칙 생성
    // SECTION 주석
    lines.push(`# [SECTION: uniques_${tier.toLowerCase()}]`);
    lines.push(`# ${tier} Tier Uniques`);
    
    // RID
    lines.push(`# [RID: uniques_tier_${tier.toLowerCase()}]`);
    lines.push("Show");

    // Rarity
    lines.push(`  Rarity == Unique`);

    // BaseType
    const baseTypeLine = items.map(name => `"${name}"`).join(" ");
    lines.push(`  BaseType == ${baseTypeLine}`);

    // Styles (Custom overrides Default)
    let styles = uniqueTierStyles[tier];
    if (!styles) {
      styles = getUniqueTierColors(tier);
    } else {
      const defaultStyles = getUniqueTierColors(tier);
      styles = { ...defaultStyles, ...styles };
    }

    lines.push(`  SetFontSize ${styles.fontSize}`);
    if (styles.textColor) {
        if (typeof styles.textColor === 'string') {
            lines.push(`  SetTextColor ${styles.textColor}`);
        } else {
            const { r, g, b, a } = styles.textColor;
            lines.push(`  SetTextColor ${r} ${g} ${b} ${a}`);
        }
    }
    if (styles.borderColor) {
        if (typeof styles.borderColor === 'string') {
            lines.push(`  SetBorderColor ${styles.borderColor}`);
        } else {
            const { r, g, b, a } = styles.borderColor;
            lines.push(`  SetBorderColor ${r} ${g} ${b} ${a}`);
        }
    }
    if (styles.backgroundColor) {
        if (typeof styles.backgroundColor === 'string') {
            lines.push(`  SetBackgroundColor ${styles.backgroundColor}`);
        } else {
            const { r, g, b, a } = styles.backgroundColor;
            lines.push(`  SetBackgroundColor ${r} ${g} ${b} ${a}`);
        }
    }
    
    if (styles.playEffect) {
      lines.push(`  PlayEffect ${styles.playEffect}`);
    }

    if (styles.minimapIcon) {
      const { size, color, shape } = styles.minimapIcon;
      lines.push(`  MinimapIcon ${size} ${color} ${shape}`);
    }

    // Sound
    if (styles.ingameSound) {
        if (!isSilent && isSndEnabled(styles)) {
             const { id, volume } = styles.ingameSound;
             lines.push(`  PlayAlertSound ${id} ${volume || 300}`);
        }
    } else if (styles.customSound) {
        if (!isSilent && isSndEnabled(styles)) {
            if (isPS5) {
                // S tier -> 1, etc. (Fallback if no ingameSound defined and we are on PS5)
                const ps5Map = { S: 1, A: 2, B: 3, C: 4 };
                lines.push(`  PlayAlertSound ${ps5Map[tier] || 4} 300`);
            } else {
                const cs = styles.customSound.startsWith("custom_sound/") ? styles.customSound : `custom_sound/${styles.customSound}`;
                lines.push(`  CustomAlertSound "${cs}" 300`);
            }
        }
    }

    lines.push("");
  });

  // 2. 사용자 정의 규칙 (settings.rules)
  // quick-filter-defaults.json에 정의된 규칙들 (HasVaal, IsVaal, Sockets 등)
  if (settings.rules) {
    settings.rules.forEach(rule => {
      if (!rule.enabled) return;
      if (rule.id === "uniques_d_other") {
          // 기타 유니크(D Tier)는 Min Tier가 D일 때만 표시? 
          // 아니면 사용자가 켰으면 무조건 표시? -> 사용자가 켰으면 무조건 표시 (enabled 체크 위에서 함)
          // 하지만 D Tier라고 간주된다면 minTier 체크를 해야 할 수도 있음.
          if (minTierVal < 5) return; // D(5)보다 minTier(예: C=4)가 작으면(상위면) D 표시 안 함
      }

      // 규칙 생성 (generateLevelingRules와 유사, 여기서는 간단히 구현)
      const ruleName = lang === "ko" ? rule.nameKo || rule.name : rule.name;
      lines.push(`# ${ruleName}`);
      lines.push(`# [RID: ${rule.id}]`);
      lines.push(rule.type === "hide" ? "Hide" : "Show");

      // Conditions
      if (rule.conditions) {
         if (rule.conditions.rarity) {
             const { operator, value } = rule.conditions.rarity;
             lines.push(`  Rarity ${operator} ${value}`);
         }
         if (rule.conditions.class) {
             const { operator, value } = rule.conditions.class;
             if (Array.isArray(value)) {
                 const valStr = value.map(v => `"${v}"`).join(" ");
                 lines.push(`  Class ${operator} ${valStr}`);
             } else {
                 lines.push(`  Class ${operator} "${value}"`);
             }
         }
         if (rule.conditions.baseType) { // baseType 처리 추가
             const { operator, value } = rule.conditions.baseType;
             if (Array.isArray(value)) {
                 const valStr = value.map(v => `"${v}"`).join(" ");
                 lines.push(`  BaseType ${operator} ${valStr}`);
             } else {
                 lines.push(`  BaseType ${operator} "${value}"`);
             }
         }
         if (rule.conditions.sockets) {
             const { operator, value } = rule.conditions.sockets;
             lines.push(`  Sockets ${operator} ${value}`);
         }
         if (rule.conditions.quality) {
             const { operator, value } = rule.conditions.quality;
             lines.push(`  Quality ${operator} ${value}`);
         }
         if (rule.conditions.hasVaalUniqueMod) {
             // HasVaalUniqueMod is not a standard filter condition syntax, 
             // but assuming PoE2 might have it or it's a placeholder.
             // If not supported, this might error in game. 
             // PoE1: HasEaterOfWorldsImplicit etc. 
             // PoE2 Filter Syntax check needed. assuming correct for now based on defaults.json
             // Actually defaults.json has 'hasVaalUniqueMod', but standard filter uses specific keywords.
             // For now, let's skip unknown conditions or output them as is if we trust defaults.
             // But 'hasVaalUniqueMod' looks like internal logic variable. 
             // Wait, standard PoE filter doesn't have HasVaalUniqueMod. 
             // It has 'Corrupted True'. 
             // But 'isVaalUnique' in defaults?
             // Let's look at defaults again. 
         }
         // Custom conditions for Vaal/Corrupted
         if (rule.id === "uniques_hasvaal" || rule.id === "uniques_isvaal") {
             // 짐작컨대 Corrupted 관련이나 특정 베이스?
             // 여기서 처리하기 애매하면 일단 넘어감 (defaults.json의 condition 값 그대로 믿음?)
             // 하지만 filter 문법으로 변환해줘야 함.
             // defaults.json의 hasVaalUniqueMod: {operator: "==", value: true}
             // 이게 무슨 의미인지 모르면 변환 불가.
             // 아마 Corrupted True 일 것임.
             // 혹은 Mirrored?
         }
      }

      // 수동 Conditions 매핑 (defaults.json에 기반)
      if (rule.id === "uniques_hasvaal" || rule.id === "uniques_isvaal") {
          // Vaal 관련
           lines.push("  Corrupted True");
      }
      
      // Styles
      const styles = rule.styles || {};
      if (styles.fontSize) lines.push(`  SetFontSize ${styles.fontSize}`);
      if (styles.textColor) {
          const { r, g, b, a } = styles.textColor;
          lines.push(`  SetTextColor ${r} ${g} ${b} ${a}`);
      }
      if (styles.borderColor) {
          const { r, g, b, a } = styles.borderColor;
          lines.push(`  SetBorderColor ${r} ${g} ${b} ${a}`);
      }
      if (styles.backgroundColor) {
          const { r, g, b, a } = styles.backgroundColor;
          lines.push(`  SetBackgroundColor ${r} ${g} ${b} ${a}`);
      }
      if (styles.playEffect) lines.push(`  PlayEffect ${styles.playEffect}`);
      if (styles.minimapIcon) {
          const { size, color, shape } = styles.minimapIcon;
          lines.push(`  MinimapIcon ${size} ${color} ${shape}`);
      }
      
      lines.push("");
    });
  }
}

function getUniqueTierColors(tier) {
  const styles = {
    S: {
      fontSize: 45,
      textColor: "175 96 37 255", // Unique Brown/Orange
      borderColor: "175 96 37 255",
      backgroundColor: "255 255 255 255",
      playEffect: "Red",
      minimapIcon: { size: 0, color: "Red", shape: "Star" },
      ingameSound: { id: 6, volume: 300 }
    },
    A: {
      fontSize: 45,
      textColor: "255 255 255 255",
      borderColor: "255 255 255 255",
      backgroundColor: "175 96 37 255",
      playEffect: "Orange",
      minimapIcon: { size: 0, color: "Orange", shape: "Star" },
      ingameSound: { id: 2, volume: 200 }
    },
    B: {
      fontSize: 40,
      textColor: "175 96 37 255",
      borderColor: "175 96 37 255",
      backgroundColor: "0 0 0 255",
      playEffect: "Yellow",
      minimapIcon: { size: 1, color: "Yellow", shape: "Star" },
      customSound: null
    },
    C: {
      fontSize: 35,
      textColor: "175 96 37 255",
      borderColor: "0 0 0 0", // No border
      backgroundColor: "0 0 0 0", // Transparent bg
      playEffect: null,
      minimapIcon: null,
      customSound: null
    },
    D: {
      fontSize: 35,
      textColor: "175 96 37 255",
      borderColor: "0 0 0 0",
      backgroundColor: "0 0 0 0",
      playEffect: null,
      minimapIcon: null,
      customSound: null
    }
  };
  return styles[tier] || styles.C;
}
/**
 * 감정된 장신구 규칙 생성
 */
function generateIdentifiedJewelleryRules(lines, settings, soundContext, lang = "ko") {
  const { isSndEnabled } = soundContext;
  if (settings.enabled === false) {
    return;
  }

  // 벨트 모드 리스트
  const beltPrefixes = ["Abating", "Athlete's", "Chalybeous", "Fecund", "Gentian", "Inspiring", "Regenerating", "Unmoving"];
  const beltSuffixes = ["of Bameth", "of Ephij", "of Haast", "of Magma", "of Tzteosh", "of the Gods", "of the Ice", "of the Lightning", "of the Titan"];
  const beltCombined = [...beltPrefixes, ...beltSuffixes, "Enveloped", "Exciting", "Galvanizing", "Opalescent", "Refreshing", "Rejuvenating", "Virile", "of Exile", "of Expulsion", "of the Leviathan", "of the Maelstrom", "of the Polar Bear", "of the Volcano"];
  const beltBadMods = ["Affecting", "Azure", "Barbed", "Beryl", "Cobalt", "Edged", "Hale", "Healthy", "Jagged", "Lacquered", "Pointed", "Restoring", "Ribbed", "Sanguine", "Spiked", "Spiny", "Studded", "Thorny", "of Convalescence", "of the Bear", "of the Brute", "of the Cloud", "of the Drake", "of the Flatworm", "of the Hydra", "of the Lizard", "of the Lost", "of the Narwhal", "of the Newt", "of the Penguin", "of the Salamander", "of the Seal", "of the Squall", "of the Starfish", "of the Storm", "of the Troll", "of the Whelpling", "of the Wrestler"];

  // 반지 (공격) 모드 리스트
  const ringAttackPrefixes = ["Adroit", "Blasting", "Cremating", "Crystalline", "Discharging", "Dragon's", "Electrocuting", "Elusory", "Entombing", "Flaring", "Magmatic", "Polar", "Ranger's", "Rotund", "Smiting", "Tempered", "Vile", "Virile"];
  const ringAttackSuffixes = ["of Bameth", "of Ephij", "of Haast", "of Magma", "of Tzteosh", "of Windfall", "of the Arid", "of the Comet", "of the Ice", "of the Jaguar", "of the Leviathan", "of the Lightning", "of the Phantom", "of the Rainbow", "of the Remora", "of the Savant", "of the Titan", "of the Virtuoso"];
  const ringAttackCombined = [...ringAttackPrefixes, ...ringAttackSuffixes, "Cauterising", "Consistent", "Coursing", "Darkened", "Glaciated", "Hailing", "Incinerating", "Malignant", "Pirate's", "Razor-sharp", "Robust", "Shocking", "Snowy", "Steady", "Striking", "Vaporous", "Volcanic", "of Excavation", "of Exile", "of Expulsion", "of Variegation", "of the Goliath", "of the Leopard", "of the Locust", "of the Maelstrom", "of the Meteor", "of the Parched", "of the Polar Bear", "of the Sage", "of the Volcano"];
  const ringAttackBadMods = ["Acrobat's", "Agile", "Bitter", "Burnished", "Buzzing", "Charged", "Chilled", "Dancer's", "Frosted", "Glinting", "Hale", "Healthy", "Heated", "Humming", "Icy", "Impure", "Polished", "Precise", "Sanguine", "Searing", "Smoking", "Smouldering", "Snapping", "of Absorption", "of Conquest", "of Consumption", "of Enveloping", "of Expertise", "of Infusion", "of Nimbleness", "of Osmosis", "of Success", "of Talent", "of Triumph", "of Vanquishing", "of Victory", "of the Bear", "of the Brute", "of the Cloud", "of the Drake", "of the Flatworm", "of the Fox", "of the Hydra", "of the Lizard", "of the Lost", "of the Lynx", "of the Mongoose", "of the Narwhal", "of the Newt", "of the Penguin", "of the Prodigy", "of the Pupil", "of the Salamander", "of the Seal", "of the Squall", "of the Starfish", "of the Storm", "of the Student", "of the Troll", "of the Whelpling", "of the Wrestler"];

  // 반지 (시전) 모드 리스트
  const ringCastingPrefixes = ["Blue", "Dragon's", "Rotund", "Virile", "Zaffre"];
  const ringCastingSuffixes = ["of Bameth", "of Ephij", "of Haast", "of Magma", "of Nirvana", "of Sortilege", "of Tzteosh", "of Windfall", "of the Comet", "of the Hearth", "of the Ice", "of the Jaguar", "of the Leviathan", "of the Lightning", "of the Phantom", "of the Rainbow", "of the Savant", "of the Titan", "of the Virtuoso"];
  const ringCastingCombined = [...ringCastingPrefixes, ...ringCastingSuffixes, "Chalybeous", "Mazarine", "Pirate's", "Robust", "of Bliss", "of Euphoria", "of Excavation", "of Exile", "of Expertise", "of Expulsion", "of Kindling", "of Variegation", "of the Goliath", "of the Leopard", "of the Maelstrom", "of the Meteor", "of the Polar Bear", "of the Sage", "of the Volcano"];
  const ringCastingBadMods = ["Azure", "Beryl", "Cobalt", "Hale", "Healthy", "Sanguine", "Teal", "of Absorption", "of Conquest", "of Consumption", "of Enveloping", "of Excitement", "of Infusion", "of Osmosis", "of Success", "of Triumph", "of Vanquishing", "of Victory", "of the Bear", "of the Brute", "of the Cloud", "of the Drake", "of the Flatworm", "of the Fox", "of the Hydra", "of the Lizard", "of the Lost", "of the Lynx", "of the Mongoose", "of the Narwhal", "of the Newt", "of the Penguin", "of the Prodigy", "of the Pupil", "of the Salamander", "of the Seal", "of the Squall", "of the Starfish", "of the Storm", "of the Student", "of the Troll", "of the Whelpling", "of the Wrestler"];

  // 목걸이 (공격) 모드 리스트
  const amuletAttackPrefixes = ["Athlete's", "Confident", "Countess'", "Dragon's", "Impregnable", "Incandescent", "Mirage's", "Ranger's", "Scintillating", "Unassailable", "Virile"];
  const amuletAttackSuffixes = ["of Bameth", "of Battle", "of Destruction", "of Ephij", "of Fleshbinding", "of Haast", "of Magma", "of Tzteosh", "of Unmaking", "of Windfall", "of Zen", "of the Ice", "of the Infinite", "of the Jaguar", "of the Leviathan", "of the Lightning", "of the Multiverse", "of the Overseer", "of the Phantom", "of the Savant", "of the Span", "of the Titan", "of the Virtuoso"];
  const amuletAttackCombined = [...amuletAttackPrefixes, ...amuletAttackSuffixes, "Consistent", "Dauntless", "Dazzling", "Girded", "Indomitable", "Marchioness'", "Nightmare's", "Optimistic", "Phantasm's", "Pirate's", "Rotund", "Steady", "Thickened", "of Calamity", "of Dueling", "of Excavation", "of Exile", "of Expulsion", "of Ferocity", "of Fury", "of Ruin", "of Serenity", "of Suturing", "of Variegation", "of the Despot", "of the Goliath", "of the Leopard", "of the Maelstrom", "of the Polar Bear", "of the Rainbow", "of the Sage", "of the Universe", "of the Volcano"];
  const amuletAttackBadMods = ["Adept's", "Apprentice's", "Glimmering", "Glittering", "Hale", "Healthy", "Occultist's", "Precise", "Professor's", "Protective", "Reinforced", "Sanguine", "Scholar's", "Shade's", "Shining", "of Convalescence", "of Expertise", "of Ire", "of Menace", "of Nimbleness", "of Recuperation", "of Sortilege", "of Talent", "of the Bear", "of the Brute", "of the Cloud", "of the Clouds", "of the Crystal", "of the Drake", "of the Enchanter", "of the Flatworm", "of the Fox", "of the Hydra", "of the Lizard", "of the Lost", "of the Lynx", "of the Mage", "of the Meteor", "of the Mongoose", "of the Narwhal", "of the Newt", "of the Penguin", "of the Prodigy", "of the Pupil", "of the Salamander", "of the Seal", "of the Sky", "of the Sorcerer", "of the Squall", "of the Starfish", "of the Storm", "of the Student", "of the Troll", "of the Whelpling", "of the Wrestler"];

  // 목걸이 (시전) 모드 리스트
  const amuletCastingPrefixes = ["Athlete's", "Confident", "Countess'", "Dragon's", "Incandescent", "Incanter's", "Mnemonic", "Scintillating", "Ultramarine", "Unassailable", "Virile", "Zaffre"];
  const amuletCastingSuffixes = ["of Bameth", "of Destruction", "of Ephij", "of Fleshbinding", "of Haast", "of Legerdemain", "of Magma", "of Nirvana", "of Tzteosh", "of Unmaking", "of Windfall", "of Zen", "of the Ice", "of the Infinite", "of the Jaguar", "of the Leviathan", "of the Lightning", "of the Multiverse", "of the Overseer", "of the Phantom", "of the Savant", "of the Sharpshooter", "of the Sorcerer", "of the Span", "of the Titan", "of the Virtuoso"];
  const amuletCastingCombined = [...amuletCastingPrefixes, ...amuletCastingSuffixes, "Blue", "Dauntless", "Dazzling", "Indomitable", "Marchioness'", "Mazarine", "Occultist's", "Optimistic", "Perceptive", "Pirate's", "Professor's", "Rotund", "of Bliss", "of Calamity", "of Euphoria", "of Excavation", "of Exile", "of Expulsion", "of Ferocity", "of Fury", "of Ruin", "of Serenity", "of Sortilege", "of Suturing", "of Variegation", "of the Despot", "of the Enchanter", "of the Fletcher", "of the Goliath", "of the Leopard", "of the Maelstrom", "of the Polar Bear", "of the Rainbow", "of the Sage", "of the Universe", "of the Volcano"];
  const amuletCastingBadMods = ["Apprentice's", "Azure", "Beryl", "Cobalt", "Consistent", "Deliberate", "Focused", "Glimmering", "Glittering", "Hale", "Healthy", "Precise", "Protective", "Reliable", "Sanguine", "Shining", "Steady", "Teal", "of Battle", "of Combat", "of Convalescence", "of Dueling", "of Excitement", "of Ire", "of Menace", "of Recuperation", "of the Bear", "of the Brute", "of the Cloud", "of the Clouds", "of the Crystal", "of the Drake", "of the Flatworm", "of the Fox", "of the Hydra", "of the Lizard", "of the Lost", "of the Lynx", "of the Meteor", "of the Mongoose", "of the Narwhal", "of the Newt", "of the Penguin", "of the Prodigy", "of the Pupil", "of the Salamander", "of the Seal", "of the Sky", "of the Squall", "of the Starfish", "of the Storm", "of the Student", "of the Troll", "of the Whelpling", "of the Wrestler"];

  settings.rules.forEach((rule) => {
    if (!rule.enabled) return;

    lines.push(`# ${lang === "ko" ? rule.nameKo : rule.name}`);
    lines.push(`# [RID: ${rule.id}]`);
    lines.push("Show");
    if (staticIdentifiedRules[rule.id]) {
      lines.push(...staticIdentifiedRules[rule.id]);
      lines.push("");
      return;
    }
    lines.push("    Identified True");

    let currentPrefixes, currentSuffixes, currentCombined, currentBadMods, currentClass;

    if (rule.id.includes("belts")) {
      currentClass = "Belts";
      currentPrefixes = beltPrefixes;
      currentSuffixes = beltSuffixes;
      currentCombined = beltCombined;
      currentBadMods = beltBadMods;
    } else if (rule.id.includes("rings_casting")) {
      currentClass = "Rings";
      currentPrefixes = ringCastingPrefixes;
      currentSuffixes = ringCastingSuffixes;
      currentCombined = ringCastingCombined;
      currentBadMods = ringCastingBadMods;
    } else if (rule.id.includes("rings")) {
      currentClass = "Rings";
      currentPrefixes = ringAttackPrefixes;
      currentSuffixes = ringAttackSuffixes;
      currentCombined = ringAttackCombined;
      currentBadMods = ringAttackBadMods;
    } else if (rule.id.includes("amulets_casting")) {
      currentClass = "Amulets";
      currentPrefixes = amuletCastingPrefixes;
      currentSuffixes = amuletCastingSuffixes;
      currentCombined = amuletCastingCombined;
      currentBadMods = amuletCastingBadMods;
    } else if (rule.id.includes("amulets")) {
      currentClass = "Amulets";
      currentPrefixes = amuletAttackPrefixes;
      currentSuffixes = amuletAttackSuffixes;
      currentCombined = amuletAttackCombined;
      currentBadMods = amuletAttackBadMods;
    }

    lines.push(`    Class == "${currentClass}"`);
    lines.push(`    HasExplicitMod >=1 ${currentPrefixes.map(m => `"${m}"`).join(" ")}`);
    lines.push(`    HasExplicitMod >=1 ${currentSuffixes.map(m => `"${m}"`).join(" ")}`);
    
    const count = rule.id.endsWith("_a") ? 4 : 3;
    lines.push(`    HasExplicitMod >=${count} ${currentCombined.map(m => `"${m}"`).join(" ")}`);
    
    if (rule.id.endsWith("_a")) {
        lines.push(`    HasExplicitMod <=1 ${currentBadMods.map(m => `"${m}"`).join(" ")}`);
    } else {
        lines.push(`    HasExplicitMod <=1 ${currentBadMods.map(m => `"${m}"`).join(" ")}`);
    }

    // 스타일 적용
    const styles = rule.styles || {};
    if (styles.fontSize) lines.push(`    SetFontSize ${styles.fontSize}`);
    if (styles.textColor) lines.push(`    SetTextColor ${styles.textColor.r} ${styles.textColor.g} ${styles.textColor.b} ${styles.textColor.a}`);
    if (styles.borderColor) lines.push(`    SetBorderColor ${styles.borderColor.r} ${styles.borderColor.g} ${styles.borderColor.b} ${styles.borderColor.a}`);
    if (styles.backgroundColor) lines.push(`    SetBackgroundColor ${styles.backgroundColor.r} ${styles.backgroundColor.g} ${styles.backgroundColor.b} ${styles.backgroundColor.a}`);
    if (styles.playEffect) lines.push(`    PlayEffect ${styles.playEffect}`);
    if (styles.minimapIcon) lines.push(`    MinimapIcon ${styles.minimapIcon.size} ${styles.minimapIcon.color} ${styles.minimapIcon.shape}`);
    if (styles.playAlertSound && isSndEnabled(styles)) lines.push(`    PlayAlertSound ${styles.playAlertSound.id} ${styles.playAlertSound.volume}`);
    if (styles.customSound && isSndEnabled(styles)) {
      const cs = styles.customSound.startsWith("custom_sound/") ? styles.customSound : `custom_sound/${styles.customSound}`;
      lines.push(`    CustomAlertSound "${cs}"`);
      if (styles.soundVolume) {
        lines.push(`    CustomAlertSoundOptional ${styles.soundVolume}`);
      }
    }

    lines.push("");
  });
}
